                                                                   
**Матрица компетентности программиста ч.I.**

<table>
  <tr>
   <td><strong>Область</strong>
   </td>
   <td><strong>Уровень</strong>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td><strong>2^n (Уровень 0)</strong>
   </td>
   <td><strong>n^2 (Уровень 1)</strong>
   </td>
   <td><strong>n (Уровень 2)</strong>
   </td>
   <td><strong>log(n) (Уровень 3)</strong>
   </td>
  </tr>
  <tr>
   <td><strong>Теория</strong>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td><strong>Структуры данных</strong>
   </td>
   <td>Не понимает разницы между массивом и связным списком.
   </td>
   <td>Может объяснить и использовать на практике массивы, связные списки, словари и т.д.
   </td>
   <td>Понимает плюсы и минусы использования тех или иных базовых структур данных (размер памяти, время выполнения операций с данными, в чем разница между массивами и связными списками в этом плане).
<p>
Может объяснить как реализовать хэш-таблицы и как обработать коллизии. Приоритетные очереди и способы их реализации, и т.д.
   </td>
   <td>Знание сложных структур данных, таких как B-дерево, Биномиальная куча и Фибоначчиевская куча, АВЛ-дерево, Красно-чёрное дерево, Косое дерево, Список с пропусками, TRIE-структуры и т.д.
   </td>
  </tr>
  <tr>
   <td><strong>Алгоритмы</strong>
   </td>
   <td>Не может найти среднее значение массива чисел. (Тяжело поверить, но встречаются и такие кандидаты на собеседовании.)
   </td>
   <td>Базовые методы сортировки и поиска. Обход и поиск в структурах данных.
   </td>
   <td>Деревья, Графы, "простой путь" и  "разделяй и властвуй"-алгоритмы. Понимает ассоциацию уровней этой матрицы.
   </td>
   <td>Может распознать и написать решение динамическим программированием, хорошо знает алгоритмы на графах, хорошо знает численные методы, может идентифицировать проблемы класса NP.
   </td>
  </tr>
  <tr>
   <td><strong>Системное программи-</strong>
<p>
<strong>рование</strong>
   </td>
   <td>Не знает что такое компилятор, компоновщик или интерпретатор.
   </td>
   <td>Базовое понимание компиляторов, компоновщиков и интерпретаторов.
<p>
Понимает, что такое ассемблерный код и как работают программы на уровне железа. Небольшое понимание виртуальной памяти и пэйджинга.
   </td>
   <td>Понимает чем отличается kernel mode от user mode, что такое мульти-трединг. Знает способы синхронизации и как реализованы примитивы синхронизации. Может читать ассемблерный код.
<p>
Понимает, как работают сети, сетевые протоколы и может реализовать передачу данных через сокеты.
   </td>
   <td>Понимает как работает весь "программный стэк": железо (CPU + Память + Кэш + Прерывания + микрокоды), двоичный код, ассемблер, статическая и динамическая линковка, компиляция, интерпретация, JIT-компиляция, сборка мусора, куча, стэк, адресация памяти.
   </td>
  </tr>
  <tr>
   <td><strong>Навыки</strong>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td><strong>Контроль версий исходников</strong>
   </td>
   <td>Бэкап исходников в папку с датой бэкапа.
   </td>
   <td>VSS и основы CVS/SVN в качестве пользователя.
   </td>
   <td>Специалист по возможностям CVS и SVN. Знает как создать, разветвить, слить репозитарий и т.д.
   </td>
   <td>Знает распределенные системы VCS. Работает с Mercurial/Darcs/Git
   </td>
  </tr>
  <tr>
   <td><strong>Автоматиза-</strong>
<p>
<strong>ция build'ов</strong>
   </td>
   <td>Знает как запустить Build из среды программирования.
   </td>
   <td>Умеет билдить из командной строки.
   </td>
   <td>Может настроить скрипт для сборки основной системы.
   </td>
   <td>Может настроить скрипт для сборки системы и документации, для сборки инсталляторов.Сделает и добавит код скрипта в систему контроля версий исходников.
   </td>
  </tr>
  <tr>
   <td><strong>Автоматизация тестирования</strong>
   </td>
   <td>Считает, что тестирование - это работа тестеров.
   </td>
   <td>Может создавать свои хорошие юнит-тесты для кода, который пишет в настоящее время.
   </td>
   <td>Пишет код в стиле Test-driven Development (TDD).
   </td>
   <td>Может создавать автоматические тесты на функционал, пользовательский интерфейс и загрузку/производительность.
   </td>
  </tr>
  <tr>
   <td><strong>Програм-</strong>
<p>
<strong>мирование</strong>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td><strong>Декомпози-</strong>
<p>
<strong>ция задачи</strong>
   </td>
   <td>Просто последовательные строчки. 
<p>
Copy/Paste - для повторного использования кода.
   </td>
   <td>Может разбивать решение задачи на несколько функций.
   </td>
   <td>Способен создавать многократно используемые функции/объекты, которые решают общие задачи.
   </td>
   <td>Использует соответствующие структуры данных и алгоритмы. Создает общий/объектно-ориентированный код, который инкапсулирует те условия задачи, которые могут быть изменены.
  <tr>
   <td><strong>Декомпози-</strong>
<p>
<strong>ция системы</strong>
   </td>
   <td>Не способен думать о системе более сложной, чем один класс или файл.
   </td>
   <td>Может произвести декомпозицию задачи и спроектировать систему в пределах одной платформы или технологии.
   </td>
   <td>Может спроектировать систему, которая охватывает несколько технологий/платформ.
   </td>
   <td>Может визуализировать и проектировать сложные системы с несколькими линейками продуктов, учитывать интеграциею с внешними системами. Также должен уметь проектировать системы поддержки работы: мониторинг, генерация отчетов, аварийные переходы на использование запасных ресурсов.
   </td>
  </tr>
  <tr>
   <td><strong>Общение</strong>
   </td>
   <td>Не может выразить свои мысли/идеи. Плохо с правописанием и грамматикой.
   </td>
   <td>Его понимают. Хорошие правописание и грамматика.
   </td>
   <td>Может эффективно общаться.
   </td>
   <td>Может понимать и объяснять мысли/дизайн/ 
<p>
идеи/специфику в точно выраженной  форме. В общении соответствует ситуации.
   </td>
  </tr>
  <tr>
   <td><strong>Организация кода в файле</strong>
   </td>
   <td>Нет четкой организации кода в файле.
   </td>
   <td>Методы сгруппированны логически и по вызовам.
   </td>
   <td>Код разделен на регионы,  имеет хорошие комментарии, в т.ч. со ссылками на другие файлы исходников.
   </td>
   <td>Файл имеет разделы "license header", "summary", хорошие комментарии, непротиворечивую расстановку пробелов и табуляции. Файл должен выглядеть красиво.
   </td>
  </tr>
  <tr>
   <td><strong>Организация кода между файлами</strong>
   </td>
   <td>Не приходит в голову мысль четко организовать код с помощью разделения на файлы.
   </td>
   <td>Похожие файлы группируются в папку.
   </td>
   <td>Каждый физический файл предназначен для чего-то одного, например, служит для объявления одного класса или для реализации одного функционала и т.д.
   </td>
   <td>Организация кода на физическом уровне точно соответствует проекту. Глядя на имена файлов и структуру папок, можно понять как спроектирована данная реализация.
   </td>
  </tr>
  <tr>
   <td><strong>Организация дерева исходников</strong>
   </td>
   <td>Все в одной папке.
   </td>
   <td>Простое разделение кода в логические подкаталоги.
   </td>
   <td>Нет "круговых" зависимостей. Бинарники, либы, документация, билды, сторонний код - все разложено в соответствующие папки.
   </td>
   <td>Структура дерева исходного кода соответствует логической иерархии и организации кода в проекте.
<p>
Глядя на имена файлов и структуру папок, можно понять как спроектирована данная система.
   </td>
  </tr>
  <tr>
   <td><strong>Читабель-</strong>
<p>
<strong>ность кода</strong>
   </td>
   <td>Односложные имена.
   </td>
   <td>Хорошие имена файлов, переменных, классов, методов и т.д.
   </td>
   <td>Нет длинных функций, а нестандартный код, багфиксы и допущения в коде поясняются комментариями.
   </td>
   <td>Допущения в коде сопровождаются assert'ами. Поток операций в коде естественный - нет глубокой вложенности условий или методов.
   </td>
  </tr>
  <tr>
   <td><strong>Безопасное программи-</strong>
<p>
<strong>рование (defensive coding)</strong>
   </td>
   <td>Не понимает данной концепции.
   </td>
   <td>Проверяет все аргументы и ставит assert'ы на критические допущения в коде.
   </td>
   <td>Убеждается, что проверил возвращаемое значение и что обрабатывает исключения в потенциально бажном коде.
   </td>
   <td>Имеет свою собственную библиотеку помогающую в <em>безопасном программировании</em>, пишет юнит-тесты которые эмулируют сбои.
   </td>
  </tr>
  <tr>
   <td><strong>Обработка ошибок</strong>
   </td>
   <td>Пишет код для "идеального" случая, когда все работает и нет сбоев.
   </td>
   <td>Обработка ошибок в коде, который либо кидает исключение, либо генерирует ошибку.
   </td>
   <td>Убеждается, что после того, как произошла ошибка/исключение, программа продолжает работать, а ненужные более ресурсы, коннекшоны и память были корректно освобождены обработчиком ошибки. 
   </td>
   <td>Пишет код так, чтобы определять возможные ошибки на раннем этапе,  придерживается последовательной стратегии обработки исключений во всех слоях кода, разрабатывает общие принципы обработки исключений во всей системе.
   </td>
  </tr>
</table>


<p style="text-align: right">
<strong> </strong></p>

_Замечание 1:_

Каждый следующий уровень включает в себя предыдущий , т.е. разработчик находящийся на уровне 3 должен удовлетворять критериям двух предыдущих уровней.

_Замечание 2:_

Версия документа от 17.05.2013. О дополнениях, ошибках  сообщайте в issues. Спасибо всем, кто помог сделать этот документ лучше!

_Замечание 3:_

Эта перевод английской версии: [Programmer Competency Matrix](http://www.indiangeek.net/wp-content/uploads/Programmer%20competency%20matrix.htm)

Вторая, еще более содержательная часть таблицы - **[Матрица компетентности программиста ч.II.>>](partII.md)**

