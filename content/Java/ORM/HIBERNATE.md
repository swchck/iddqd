# Object Relational Mapping (ORM) Hibernate

## Что такое Hibernate

Это фреймворк для объектно-реляционного отображения сущностей в традиционные реляционные базу данных.
Основные возможности фреймворка:
Автоматическая генерация и обновление таблиц в базах данных;
Поскольку основные запросы к базе данных (сохранение, обновление, удаление и поиск) представлены как методы фрейморка, то значительно сокращается код, который пишется разработчиком;
Обеспечивает использование SQL подобного языка (HQL - Hibernate Query Language). Запросы HQL могут быть записаны рядом объектами данных (`POJO` классы подготовленные для работы с базой данных).

## Что такое ORM

ORM (англ. Object Relational Mapping) - технология программирования,
которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая "виртуальную объектную базу данных".

## Какие преимущства от использования Hibernate

Некоторые из них:

- Устраняет множество повторяющегося кода, который постоянно преследует разработчика при работе с JDBC. Скрывает от разработчика множество кода, необходимого для управления ресурсами и позволяет сосредоточиться на бизнес логике.
- Поддерживает XML так же как и JPA аннотации, что позволяет сделать реализацию кода независимой.
- Предоставляет собственный мощный язык запросов (HQL), который похож на SQL. Стоит отметить, что HQL полностью объектно-ориентирован и понимает такие принципы, как наследование, полиморфизм и ассоциации (связи).
- Hibernate легко интегрируется с другими Java EE фреймворками, например, Spring Framework поддерживает встроенную интеграцию с Hibernate.
- Поддерживает ленивую инициализацию используя proxy объекты и выполняет запросы к базе данных только по необходимости.
- Поддерживает разные уровни cache, а следовательно может повысить производительность.
- Важно, что Hibernate может использовать чистый SQL, а значит поддерживает возможность оптимизации запросов и работы с любым сторонним вендором БД.
- Hibernate - open source проект. Благодаря этому доступны тысячи открытых статей, примеров, а так же документации по использованию фреймворка.

### Как Hibernate помогает в программировании

Hibernate реализует ряд фичь которые значительно упрощают работу разработчика.
Одной из таких фич является то, что Hibernate позволяет разработчику избежать написания большинства SQL запросов (они уже реализованы , вам надо просто использовать методы которые предоставляет фреймворк).

Под бортом у Hibernate есть куча полезных инструментов которые значительно ускоряют работу приложения, самыми примечательными из них являются двухуровневое кэширования и тонкие настройки lazy и fetch изъятия.
А так же, сам генерирует таблицы в базу данных.

### Какие преимущества Hibernate над JDBC

Hibernate имеет ряд преимуществ перед JDBC API:

- Hibernate удаляет множество повторяющегося кода из JDBC API, а следовательно его легче читать, писать и поддерживать.
- Hibernate поддерживает наследование, ассоциации и коллекции, что не доступно в JDBC API.
- Hibernate неявно использует управление транзакциями. Большинство запросов нельзя выполнить вне транзакции. При использовании JDBC API для управления транзакциями нужно явно использовать commit и rollback.
- JDBC API throws SQLException, которое относится к проверяемым исключениям, а значит необходимо постоянно писать множество блоков try-catch. В большинстве случаев это не нужно для каждого вызова JDBC и используется для управления транзакциями. Hibernate оборачивает исключения JDBC через непроверяемые JDBCException или HibernateException, а значит нет необходимости проверять их в коде каждый раз. Встроенная поддержка управления транзакциями в Hibernate убирает блоки try-catch.
- Hibernate Query Language (HQL) более объектно ориентированный и близкий к Java язык программирования, чем SQL в JDBC.
- Hibernate поддерживает кэширование, а запросы JDBC - нет, что может понизить производительность.
- Hibernate предоставляет возможность управления БД (например создания таблиц), а в JDBC можно работать только с существующими таблицами в базе данных.
- Конфигурация Hibernate позволяет использовать JDBC вроде соединения по типу JNDI DataSource для пула соединений. Это важная фича для энтерпрайз приложений, которая полностью отсутствует в JDBC API.
- Hibernate поддерживает аннотации JPA, а значит код является переносимым на другие ORM фреймворки, реализующие стандарт, в то время как код JDBC сильно привязан к приложению.

## Что такое конфигурационный файл Hibernate

Файл конфигурации Hibernate содержит в себе данные о базе данных и необходим для инициализации SessionFactory. В .xml файле необходимо указать вендора базы данных или JNDI ресурсы, а так же информацию об используемом диалекте, что поможет hibernate выбрать режим работы с конкретной базой данных.

### Способы конфигурации работы с Hibernate

Существует четыре способа конфигурации работы с Hibernate :

- Annotation;
- Hibernate.cfg.xml
- Hibernate.properties
- Persistence.xml

Самый частый способ конфигурации: через аннотации и файл persistence.xml, что касается файлов hibernate.properties и hibernate.cfg.xml, то hibernate.cfg.xml главнее (если в приложение есть оба файла, то принимаются настройки из файла hibernate.cfg.xml). Конфигурация аннотациями, хоть и удобна, но не всегда возможна, к примеру, если для разных баз данных или для разных ситуаций вы хотите иметь разные конфигурацию сущностей, то следует использовать xml файлы конфигураций.

### Что такое Hibernate mapping file

Mapping file используется для связи entity бинов и колонок в таблице базы данных. В случаях, когда не используются аннотации JPA, файл отображения .xml может быть полезен (например при использовании сторонних библиотек).

## Что такое Переходные объекты (Transient Objects)

Экземпляры долгоживущих классов, которые в настоящее время не связаны c Cессией. Они, возможно, были инициализированы в приложении и еще не сохранены, или же они были инициализированы закрытой Cессией.

## Что такое постоянные объекты (Persistent objects)

Короткоживущие, однопоточные объекты, содержащие постоянное состояние и бизнес-функции. Это могут быть простые Java Beans/POJOs. Они связаны только с одной Cессией. После того, как Cессия закрыта, они будут отделены и свободны для использования в любом протоколе прикладного уровня (например, в качестве объектов передачи данных в и из представления).

## Что такое **TransactionFactory**

Фабрика для экземпляров Transaction. Интерфейс не открыт для приложения, но может быть расширен или реализован разработчиком.

## Что такое **ConnectionProvider**

Фабрика и пул JDBC соединений. Интерфейс абстрагирует приложение от основного источника данных или диспетчера драйверов. Он не открыт для приложения, но может быть расширен или реализован разработчиком.

## Что такое Трансакция (Transaction)

Однопоточный, короткоживущий объект, используемый приложением для указания `atomic` переменных работы. Он абстрагирует приложение от основных JDBC, JTA или CORBA трансакций. Сессия может охватывать несколько Трансакций в некоторых случаях. Тем не менее, разграничение транзакций, также используемое в основах API или Transaction, всегда обязателно.

## Какие существуют стратегии загрузки объектов в Hibernate

Существуют следующие типа fetch'a:

- Join fetching: hibernate получает ассоциированные объекты и коллекции одним SELECT используя OUTER JOIN
- Select fetching: использует уточняющий SELECT чтобы получить ассоциированные объекты и коллекции. Если вы не установите lazy fetching определив lazy="false", уточняющий SELECT будет выполнен только когда вы запрашиваете доступ к ассоциированным объектам
- Subselect fetching: поведение такое же, как у предыдущего типа, за тем исключением, что будут загружены ассоциации для все других коллекций, "родительским" для которых является сущность, которую вы загрузили первым SELECT’ом.
- Batch fetching: оптимизированная стратегия вида select fetching. Получает группу сущностей или коллекций в одном SELECT

## Какие бывают id generator классы в Hibernate

- increment - генерирует идентификатор типа long, short или int, которые будет уникальным только в том случае, если другой процесс не добавляет запись в эту же таблицу в это же время.
- identity - генерирует идентификатор типа long, short или int. Поддерживается в DB2, MySQL, MS SQL Server, Sybase и HypersonicSQL.
- sequence - использует последовательности в DB2, PostgreSQL, Oracle, SAP DB, McKoi или генератор Interbase. Возвращает идентификатор типа long, short или int.
- hilo - использует алгоритм hi/lo для генерации идентификаторов типа long, short или int. Алгоритм гарантирует генерацию идентификаторов, которые уникальны только в данной базе данных.
- seqhilo - использует алгоритм hi/lo для генерации идентификаторов типа long, short или int учитывая последовательность базы данных.
- uuid - использует для генерации идентификатора алгоритм 128-bit UUID. Идентификатор будет уникальным в пределах сети. UUID представляется строкой из 32 чисел.
- guid - использует сгенерированую БД строку GUID в MS SQL Server и MySQL.
- native - использует identity, sequence или hilo в завимисимости от типа БД, с которой работает приложение
- assigned - позволяет приложению устанавливать идентификатор объекту, до вызова метода save(). Используется по умолчанию, если тег `<generator>` не указан.
- select - получает первичный ключ, присвоенный триггером БД
- foreign - использует идентификатор другого, связанного с данным объекта. Используется в `<one-to-one>` ассоциации первичных ключей.
- sequence-identity - специализированный генератор идентификатора.

## Какие ключевые интерфейсы использует Hibernate

Существует пять ключевых интерфейсов которые используются в каждом приложении связанном с Hibernate:

- Session interface
- SessionFactory interface
- Configuration interface
- Transaction interface
- Query and Criteria interfaces

## Назовите некоторые важные аннотации, используемые для отображения в Hibernate

Hibernate поддерживает как аннотации из JPA, так и свои собственные, которые находятся в пакете org.hibernate.annotations. Наиболее важные аннотации JPA и Hibernate:

- `javax.persistence.Entity`: используется для указания класса как entity bean.
- `javax.persistence.Table`: используется для определения имени таблицы из БД, которая будет отображаться на entity bean.
- `javax.persistence.Access`: определяет тип доступа, поле или свойство. Поле — является значением по умолчанию и если нужно, чтобы hibernate использовать методы getter/setter, то их необходимо задать для нужного свойства.
- `javax.persistence.Id`: определяет primary key в entity bean.
- `javax.persistence.EmbeddedId`: используется для определения составного ключа в бине.
- `javax.persistence.Column`: определяет имя колонки из таблицы в базе данных.
- `javax.persistence.GeneratedValue`: задает стратегию создания основных ключей. Используется в сочетании с - `javax.persistence.GenerationType` `enum`.
- `javax.persistence.OneToOne`: задает связь один-к-одному между двумя сущностными бинами. Соответственно есть другие аннотации `OneToMany`, `ManyToOne` и `ManyToMany`.
- `org.hibernate.annotations.Cascade`: определяет каскадную связь между двумя `entity` бинами. Используется в связке с org.hibernate.annotations.CascadeType.
- `javax.persistence.PrimaryKeyJoinColumn`: определяет внешний ключ для свойства. Используется вместе с `org.hibernate.annotations.GenericGenerator` и `org.hibernate.annotations.Parameter`.

## Какая роль интерфейса `Session` в Hibernate

`Session` - это основной интерфейс, который отвечает за связь с базой данных. Так же, он помогает создавать объекты запросов для получение персистентных объектов. (персистентный объект - объект который уже находится в базе данных; объект запроса - объект который получается когда мы получаем результат запроса в базу данных, именно с ним работает приложение). Обьект `Session` можно получить из `SessionFactory`:

```Java
Session session = sessionFactory.openSession();
```

Роль интерфейса `Session`:
является оберткой для jdbc подключения к базе данных;
является фабрикой для транзакций (согласно официальной документации transaction - аllows the application to define units of work, что , по сути, означает что транзакция определяет границы операций связанных с базой данных).
является хранителем обязательного кэша первого уровня.

## Какая роль интерфейса `SessionFactory` в Hibernate

Именно из объекта `SessionFactory` мы получаем объекты типа Session. На все приложение существует только одна `SessionFactory` и она инициализируеться вместе со стартом приложения. `SessionFactory` кэширует мета-дату и SQL запросы которые часто используются приложением во время работы. Так же оно кэширует информацию которая была получена в одной из транзакций и может быть использована и в других транзакциях.
Обьект `SessionFactory` можно получить следующим обращением:

```Java
SessionFactory sessionFactory = configuration.buildSessionFactory();
```

## Является ли Hibernate `SessionFactory` потокобезоспансым

Т.к. объект `SessionFactory` `immutable` (неизменяемый), то да, он потокобезопасный. Множество потоков может обращаться к одному объекту одновременно.

## В чем разница между `openSession()` и `getCurrentSession()`

Hibernate SessionFactory getCurrentSession() возвращает сессию, связанную с контекстом. Но для того, чтобы это работало, нам нужно настроить его в конфигурационном файле hibernate. Так как этот объект session связан с контекстом hibernate, то отпадает необходимость к его закрытию. Объект session закрывается вместе с закрытием `SessionFactory`.

```XML
<property name="hibernate.current_session_context_class">thread</property>
```

Метод `openSession()` всегда создает новую сессию. Мы должны обязательно контролировать закрытие объекта сеанса по завершению всех операций с базой данных. Для многопоточной среды необходимо создавать новый объект session для каждого запроса.

Существует еще один метод `openStatelessSession()`, который возвращает `Session` без поддержки состояния. Такой объект не реализует первый уровень кэширования и не взаимодействует с вторым уровнем. Сюда же можно отнести игнорирование коллекций и некоторых обработчиков событий. Такие объекты могут быть полезны при загрузке больших объемов данных без удержания большого кол-ва информации в кэше.

## Какие типы коллекций представлены в Hibernate

- `Bag`
- `Set`
- `List`
- `Map`
- `Array`

## Какие типы менеджмента транзакций поддерживаются в Hibernate

Hibernate взаимодействует с БД через JDBC-соединение. Таким образом он поддерживает управляемые и не управляемые транзакции.
Неуправляемые транзакции в web-контейнере:

```XML
<bean id="transactionManager" class="org.springframework.orm.hibernate.HibernateTransactionManager">
    <property name="sessionFactory">
        <ref local="sessionFactory" />
    </property>
</bean>
```

Управляемые транзакции на сервере приложений, использующий JTA:

```XML
<bean id="transactionManager" class="org.springframework.transaction.jtaTransactionManager">
    <property name="sessionFactory">
        <ref local="sessionFactory" />
    </property>
</bean>
```

## Что собой являет коллекция типа `Bag` и зачем она используется

Своей реализации тип коллекции `Bag` очень напоминает `Set`, разница состоит в том, что `Bag` может хранить повторяющиеся значения. `Bag` хранит непроиндексированный список элементов. Большинство таблиц в базе данных имеют индексы отображающие положение элемента данных один относительно другого, данные индексы имеют представление в таблице в виде отдельной колонки. При объектно-реляционном маппинге, значения колонки индексов мапится на индекс в `Array`, на индекс в `List` или на `key` в `Map`. Если вам надо получить коллекцию объектов не содержащих данные индексы, то вы можете воспользоваться коллекциями типа `Bag` или `Set` (коллекции содержат данные в неотсортированном виде, но могут быть отсортированы согласно запросу).

## Какие типы кэша используются в Hibernate

Hibernate использует 2 типа кэша: кэш первого уровня и кэш второго уровня.
Кэш первого уровня ассоциирован с объектом сесии, в то время, как кэш второго уровня ассоциирован с объектом фабрики сессий. По-умолчанию Hibernate использует кэш первого уровня для каждой операции в транзакции. В первую очередь кэш используется чтобы уменьшить количество SQL-запросов. Например если объект модифицировался несколько раз в одной и той же транзакции, то Hibernate сгенерирует только один UPDATE.
Чтобы уменьшить трафик с БД, Hibernate использует кэш второго уровня, который является общим для всего приложения, а не только для данного конкретного пользователя. Таким образом если результат запроса находится в кэше, мы потенциально уменьшаем количество транзакций к БД.
EHCache - это быстрый и простой кэш. Он поддерживает read-only и read/write кэширование, а так же кэширование в память и на диск. Но не поддерживает кластеризацию.
OSCache - это другая opensource реализация кэша. Помимо всего, что поддерживает EHCache, эта реализация так же поддерживает кластеризацию через JavaGroups или JMS.
SwarmCache - это просто cluster-based решение, базирующееся на JavaGroups. Поддерживает read-only и нестрогое read/write кэширование. Этот тип кэширование полезен, когда количество операций чтения из БД превышает количество операций записи.
JBoss TreeCache - предоставляет полноценный кэш транзакции.

### Какие существуют типы стратегий кэша

Read-only: эта стратегия используется когда данные вычитываются, но никогда не обновляется. Самая простая и производительная стратегия
Read/write: может быть использована, когда данные должны обновляться.
Нестрогий read/write: эта стратегия не гарантирует, что две транзакции не модифицируют одни и те же данные синхронно.
Transactional: полноценное кэширование транзакций. Доступно только в JTA окружении.

### Что вы знаете о кэширование в Hibernate? Объясните понятие кэш первого уровня в Hibernate

Hibernate использует кэширование, чтобы сделать приложение быстрее. идея кэширования заключается в сокращении количества запросов к БД.

Кэщ первого уровня Hibernate, связан с объектом Session. Кэш первого уровня у Hibernate включен по умолчаню и не существует никакого способа, чтобы его отключить. Однако Hibernate предоставляет методы, с помощью которых мы можем удалить выбранные объекты из кэша или полностью очистить кэш.

Любой объект закэшированный в Session не будет виден другим объектам Session, после закрытия сессии, все кэшированные объекты будут потеряны.

## Как настраивается кэш второго уровня в Hibernate

Чтобы указать кэш второго уровня нужно определить hibernate.cache.provider_class в hibernate.cfg.xml:

```XML
<hibernate-configuration>
    <session-factory>
        <property name="hibernate.cache.provider_class">org.hibernate.cache.EHCacheProvider</property>
    </session-factory>
</hibernate-configuration>
```

По-умолчанию используется EHCache.
Чтобы использвать кэш запросов нужно его включить установив свойство hibernate.cache.use_query_cache в true в hibernate.properties.

## Какая разница в работе методов load() и get()

Hibernate session обладает различными методами для загрузки данных из базы данных. Наиболее часто
используемые методы для этого - get() и load().
Метод load(); обычно используется когда в не уверен что запрашиваемый объект уже находится в базе данных. Если объект не найден, то метод кидает исключение Если объект найден — метод возвращает прокси объект, который является ссылкой на объект находящийся в базе данных (запрос в базу данных еще не был осуществлен, своего рода lazy изъятие), непосредственный запрос к базе данных когда мы непосредственно обращаемся к необходимому объекту через прокси объект.
Метод get(); используется тогда, вы на 100 процентов не уверены есть ли запрашиваемый объект в базе данных. В случае обращение к несуществующему объекту, метод get(); вернет null. В случае нахождения объект, метод get(); вернет сам объект и запрос в базу данных будет произведен немедленно.

## Каковы существуют различные состояния у entity bean

Transient: состояние, при котором объект никогда не был связан с какой-либо сессией и не является персистентностью. Этот объект находится во временном состоянии. Объект в этом состоянии может стать персистентным при вызове метода save(), persist() или saveOrUpdate(). Объект персистентности может перейти в transient состоянии после вызова метода delete().
Persistent: когда объект связан с уникальной сессией он находится в состоянии persistent (персистентности). Любой экземпляр, возвращаемый методами get() или load() находится в состоянии persistent.
Detached: если объект был персистентным, но сейчас не связан с какой-либо сессией, то он находится в отвязанном (detached) состоянии. Такой объект можно сделать персистентным используя методы update(), saveOrUpdate(), lock() или replicate(). Состояния transient или detached так же могут перейти в состояние persistent как новый объект персистентности после вызова метода merge().

## Что произойдет, если будет отсутствовать конструктор без аргументов у Entity Bean

Hibernate использует рефлексию для создания экземпляров Entity бинов при вызове методов get() или load(). Для этого используется метод Class.newInstance(), который требует наличия конструктора без параметров. Поэтому, в случае его отсутствия, вы получите ошибку HibernateException.

## Как используется вызов метода Hibernate Session merge()

Hibernate merge() может быть использован для обновления существующих значений, однако этот метод создает копию из переданного объекта сущности и возвращает его. Возвращаемый объект является частью контекста персистентности и отслеживает любые изменения, а переданный объект не отслеживается.

## В чем разница между Hibernate save(), saveOrUpdate() и persist()

Hibernate save() используется для сохранения сущности в базу данных. Проблема с использованием метода save() заключается в том, что он может быть вызван без транзакции. А следовательно если у нас имеется отображение нескольких объектов, то только первичный объект будет сохранен и мы получим несогласованные данные. Также save() немедленно возвращает сгенерированный идентификатор.
Hibernate persist() аналогичен save() с транзакцией. persist() не возвращает сгенерированный идентификатор сразу.
Hibernate saveOrUpdate() использует запрос для вставки или обновления, основываясь на предоставленных данных. Если данные уже присутствуют в базе данных, то будет выполнен запрос обновления. Метод saveOrUpdate() можно применять без транзакции, но это может привести к аналогичным проблемам, как и в случае с методом save().

## Что такое Lazy fetching(изъятие) в Hibernate

Тип изьятия Lazy, в Hibernate, связан с листовыми(дочерними) сущностями и определяют политику совместного изъятия, если идет запрос на изъятие сущности родителя.
Простой пример:
Есть сущность Дом. Он хранит информацию о своем номере, улице, количество квартир и информацию о семьях которые живут в квартирах, эти семьи формируют дочернюю сущность относительно сущности Дом. Когда мы запрашиваем информацию о Доме, нам может быть совершенно ненужным знать информацию семьях которые в нем проживают, тут нам на помощь приходит lazy(ленивое) изъятие(fetching) которая позволяет сконфигурировать сущность Дом, чтобы информацию о семьях подавалась только по востребованию, это значительно облегчает запрос и ускоряет работу приложения.

## В чем разница между sorted collection и ordered collection? Какая из них лучше

При использовании алгоритмов сортировки из Collection API для сортировки коллекции, то он вызывает отсортированный список (sorted list). Для маленьких коллекций это не приводит к излишнему расходу ресурсов, но на больших коллекциях это может привести к потери производительности и ошибкам OutOfMemory. Так же entity бины должны реализовывать интерфейс Comparable или Comparator для работы с сортированными коллекциями.
При использовании фреймворка Hibernate для загрузки данных из базы данных мы можем применить Criteria API и команду order by для получения отсортированного списка (ordered list). Ordered list является лучшим выбором к sorted list, т.к. он использует сортировку на уровне базы данных. Она быстрее и не может привести к утечке памяти.

## Как реализованы Join’ы Hibernate

Существует несколько способов реализовать связи в Hibernate.
Использовать ассоциации, такие как one-to-one, one-to-many, many-to-many.
Использовать в HQL запросе команду JOIN. Существует другая форма «join fetch«, позволяющая загружать данные немедленно (не lazy).
Использовать чистый SQL запрос с командой join.

## Почему мы не должны делать Entity class как final

Хибернейт использует прокси классы для ленивой загрузки данных (т.е. по необходимости, а не сразу). Это достигается с помощью расширения entity bean и, следовательно, если бы он был final, то это было бы невозможно. Ленивая загрузка данных во многих случаях повышает производительность, а следовательно важна.

## Что вы знаете о HQL и каковы его преимущества

Hibernate Framework поставляется с мощным объектно-ориентированным языком запросов - Hibernate Query Language (HQL). Он очень похож на SQL, за исключением, что в нем используются объекты вместо имен таблиц, что делает язык ближе к объектно-ориентированному программированию.
HQL является регистронезависимым, кроме использования в запросах имен java переменных и классов, где он подчиняется правилам Java. Например, SelECt то же самое, что и select, но com.blogspot.jsehelper.MyClass отличен от  com.blogspot.jsehelper.MyCLASS. Запросы HQL кэшируются (это как плюс так и минус).

## Что такое Query Cache в Hibernate

Hibernate реализует область кэша для запросов resultset, который тесно взаимодействует с кэшем второго уровня Hibernate. Для подключения этой дополнительной функции требуется несколько дополнительных шагов в коде. Query Cache полезны только для часто выполняющихся запросов с повторяющимися параметрами. Для начала необходимо добавить эту запись в файле конфигурации Hibernate:

```XML
<property name="hibernate.cache.use_query_cache">true</property>
```

Уже внутри кода приложения для запроса применяется метод setCacheable(true), как показано ниже:

```Java
Query query = session.createQuery("from Employee");
query.setCacheable(true);
query.setCacheRegion("ALL_EMP");
```

## Можем ли мы выполнить SQL запрос в Hibernate

С помощью использования SQLQuery можно выполнять чистый запрос SQL. В общем случае это не рекомендуется, т.к. вы потеряете все преимущества HQL (ассоциации, кэширование). Выполнить можно примерно так:

```Java
Transaction tx = session.beginTransaction();
SQLQuery query = session.createSQLQuery("SELECT * FROM Employee");
List<Object[]> rows = query.list();
for(Object[] row : rows) {
    Employee emp = new Employee();
    emp.setId(Long.parseLong(row[0].toString()));
    emp.setName(row[1].toString());
    emp.setSalary(Double.parseDouble(row[2].toString()));
    System.out.println(emp);
}
```

## Назовите преимущества поддержки нативного sql в Hibernate

Использование нативного SQL может быть необходимо при выполнении запросов к некоторым базам данных, которые могут не поддерживаться в Hibernate. Примером может служить некоторые специфичные запросы и «фишки» при работе с БД от Oracle.

## Что такое Named SQL Query

Hibernate поддерживает именованный запрос, который мы можем задать в каком-либо центральном месте и потом использовать его в любом месте в коде. Именованные запросы поддерживают как HQL, так и Native SQL. Создать именованный запрос можно с помощью JPA аннотаций @NamedQuery, @NamedNativeQuery или в конфигурационном файле отображения (mapping files).

### Каковы преимущества Named SQL Query

- Именованный запрос Hibernate позволяет собрать множество запросов в одном месте, а затем вызывать их в любом классе.
- Синтаксис Named Query проверяется при создании session factory, что позволяет заметить ошибку на раннем этапе, а не при запущенном приложении и выполнении запроса.
- Named Query глобальные, т.е. заданные однажды, могут быть использованы в любом месте.
Однако одним из основных недостатков именованного запроса является то, что его очень трудно отлаживать (могут быть сложности с поиском места определения запроса).

## Как добавить логирование log4j в Hibernate приложение

Добавить зависимость log4j в проект.
Создать log4j.xml или log4j.properties файл и добавить его в classpath.
Для веб приложений используйте ServletContextListener, а для автономных приложений DOMConfigurator или PropertyConfigurator для настройки логирования.
Создайте экземпляр org.apache.log4j.Logger и используйте его согласно задачи.

## Как логировать созданные Hibernate SQL запросы в лог-файлы

Для логирования запросов SQL добавьте в файл конфигурации Hibernate строчку

```XML
<property name="hibernate.show_sql">true</property>
```

## Что вы знаете о Hibernate прокси и как это помогает в ленивой загрузке (lazy load)

Hibernate использует прокси объект для поддержки отложенной загрузки. Обычно при загрузке данных из таблицы Hibernate не загружает все отображенные (замаппинные) объекты. Как только вы ссылаетесь на дочерний объект или ищите объект с помощью геттера, если связанная сущность не находиться в кэше сессии, то прокси код перейдет к базе данных для загрузки связанной сущности. Для этого используется javassist, чтобы эффективно и динамически создавать реализации подклассов ваших entity объектов.

## Как управлять транзакциями с помощью Hibernate

Hibernate вообще не допускает большинство операций без использования транзакций. Поэтому после получения экземпляра session от SessionFactory необходимо выполнить beginTransaction() для начала транзакции. Метод вернет ссылку, которую мы можем использовать для подтверждения или отката транзакции.
В целом, управление транзакциями в фреймворке выполнено гораздо лучше, чем в JDBC, т.к. мы не должны полагаться на возникновение исключения для отката транзакции. Любое исключение автоматически вызовет rollback.

## Что такое каскадные связи (обновления) в Hibernate

Если у нас имеются зависимости между сущностями (entities), то нам необходимо определить как различные операции будут влиять на другую сущность. Это реализуется с помощью каскадных связей (или обновлений). Вот пример кода с использованием аннотации @Cascade:

```Java
import org.hibernate.annotations.Cascade;

@Entity
@Table(name="Employee")
public class Employee {

    @OneToOne(mappedBy = "employee")
    @Cascade(value = org.hibernate.annotations.CascadeType.ALL)
    private Address address;
}
```

Есть некоторые различия между enum CascadeType в Hibernate и в JPA. Поэтому обращайте внимание какой пакет вы импортируете при использовании аннотации и константы типа.

### Какие каскадные типы есть в Hibernate

Наиболее часто используемые CascadeType перечисления описаны ниже:

- None: без Cascading. Формально это не тип, но если мы не указали каскадной связи, то никакая операция для родителя не будет иметь эффекта для ребенка.
- ALL: Cascades save, delete, update, evict, lock, replicate, merge, persist. В общем — всё.
- SAVE_UPDATE: Cascades save и update. Доступно только для hibernate.
- DELETE: передает в Hibernate native DELETE действие. Только для hibernate.
- DETATCH, MERGE, PERSIST, REFRESH и REMOVE – для простых операций.
- LOCK: передает в Hibernate native LOCK действие.
- REPLICATE: передает в Hibernate native REPLICATE действие.

## Что такое сесиия и фаблика сессий в Hibernate? Как настроить session factory в конфигурационном файле Spring

Hibernate сессия - это главный интерфейс взаимодействия Java-приложения и Hibernate. SessionFactory позволяет создавать сессии согласно конфигурации hibernate.cfg.xml. Например:

```Java
// Initalize the Hibernate environment
Configuration cfg = new Configuration().configure();
// Create the session factory
SessionFactory factory = cfg.buildSessionFactory();
// Obtain the new session object
Session session = factory.openSession();
```

При вызове Configuration().configure() загружается файл hibernate.cfg.xml и происходит настройка среды Hibernate. После того, как конфигурация загружена, вы можете сделать дополнительную модификацию настроек уже на программном уровне. Данные корректировки возможны до создания экземпляра фабрики сессий. Экземпляр SessionFactory как правило создается один раз и используется во всем приложении.
Главная задача сессии - обеспечить механизмы создания, чтения и удаления для экземпляров примапленых к БД классов. Экземпляры могут находиться в трёх состояниях:
transient - никогда не сохранялись, не ассоциированы ни с одной сессией;
persistent - ассоциированы с уникальной сессией;
detached - ранее сохраненные, не ассоциированы с сессией.
Объект Hibernate Session представляет одну операцию с БД. Сессию открывает фабрика сессий. Сессия должна быть закрыта, когда все операции с БД совершены. Пример:

```Java
Session session = null;
UserInfo user = null;
Transaction tx = null;

try {
    session = factory.openSession();
    tx = session.beginTransaction();
    user = (UserInfo) session.load(UserInfo.class, id);
    tx.commit();
} catch(Exception e) {
    if (tx != null) {
        try {
            tx.rollback();
        } catch (HibernateException he) {
            throw new DAOException(he.toString());
        }
    }
    throw new DAOException(e.toString());
} finally {
    if (session != null) {
        try {
            session.close();
        } catch (HibernateException e) {

        }
    }
}
```

## Как использовать JNDI DataSource сервера приложений с Hibernate Framework

В веб приложении лучше всего использовать контейнер сервлетов для управления пулом соединений. Поэтому лучше определить JNDI ресурс для DataSource и использовать его в веб приложении. Для этого в Hibernate нужно удалить все специфичные для базы данных свойства из и использовать указания свойства JNDI DataSource:

```XML
<property name="hibernate.connection.datasource">java:comp/env/jdbc/localdb</property>
```

## Как интегрировать Hibernate и Spring

Лучше всего прочитать о настройках на сайтах фреймворков для текущей версии. Оба фреймворка поддерживают интеграцию из коробки и в общем настройка их взаимодействия не составляет труда. Общие шаги выглядят следующим образом.

- Добавить зависимости для hibernate-entitymanager, hibernate-core и spring-orm.
- Создать классы модели и передать реализации DAO операции над базой данных. Важно, что DAO классы используют SessionFactory, который внедряется в конфигурации бинов Spring.
- Настроить конфигурационный файл Spring (смотрите в офф. документации или из примера на этом сайте).
- Дополнительно появляется возможность использовать аннотацию @Transactional и перестать беспокоиться об управлением транзакцией Hibernate.

## Какие паттерны применяются в Hibernate

Domain Model Pattern - объектная модель предметной области, включающая в себя как поведение так и данные.
Data Mapper - слой мапперов (Mappers), который передает данные между объектами и базой данных, сохраняя их независимыми друг от друга и себя.
Proxy Pattern - применяется для ленивой загрузки.
Factory pattern - используется в SessionFactory

## Расскажите о Hibernate Validator Framework

Проверка данных является неотъемлемой частью любого приложения. Hibernate Validator обеспечивает эталонную реализацию двух спецификаций JSR-303 и JSR-349 применяемых в Java. Для настройки валидации в Hibernate необходимо сделать следующие шаги.

- Добавить hibernate validation зависимости в проект

```XML
<dependency>
    <groupid>javax.validation</groupid>
    <artifactid>validation-api</artifactid>
    <version>${validation-api-version}</version>
</dependency>
<dependency>
    <groupid>org.hibernate</groupid>
    <artifactid>hibernate-validator</artifactid>
    <version>${hibernate-vlidator-version}</version>
</dependency>
```

- Так же требуются зависимости из JSR 341, реализующие Unified Expression Language для обработки динамических выражений и сообщений о нарушении ограничений

```XML
<dependency>
    <groupid>javax.el</groupid>
    <artifactid>javax.el-api</artifactid>
    <version>${el-api-version}</version>
</dependency>
<dependency>
    <groupid>org.glassfish.web</groupid>
    <artifactid>javax-el</artifactid>
    <version>${javax-el-version}</version>
</dependency>
```

- Использовать необходимые аннотации в бинах

```Java
import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

import org.hibernate.validator.constraints.CreditCardNumber;
import org.hibernate.validator.constraints.Email;

public class Employee {

    @Min(value=1, groups=EmpIdCheck.class)
    private int id;

    @NotNull(message="Name cannot be null")
    @Size(min=5, max=30)
    private String name;

    @Email
    private String email;

    @CreditCardNumber
    private String creditCardNumber;
}
```
