# Types

## ~~Можно ли наследовать строковый тип~~

Классы объявлены `final`, поэтому наследоваться не получится

### Почему строка является популярным ключом в HashMap в Java

Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует повторного пересчета. Это делает строки отличным кандидатом для ключа в Map и они обрабатываются быстрее, чем другие объекты-ключи HashMap. Вот почему строки преимущественно используются в качестве ключей HashMap.

### Что такое конкатенация строк

Конкатенация - операция объединения строк. Результатом является объединения второй строки с окончанием первой. Операция конкатенации могут быть выполнены так:

```Java
StringBuffer stringBuffer = new StringBuffer();
StringBuilder stringBuilder = new StringBuilder();
String str = "Hello";

str += "World!";
String strTwo = "Hello".concat("World").concat("!");
stringBuffer.append("Hello").append("World!");
stringBuilder.append("Hello").append("World!");

Sustem.out.println(str); // HelloWorld!
Sustem.out.println(strTwo); // HelloWorld!
Sustem.out.println(stringBuffer.toString()); // HelloWorld!
Sustem.out.println(stringBuilder.toString()); // HelloWorld!
```

### Как перевернуть строку

Один из способов как это можно сделать:

```Java
String str = "Hello World!"
StringBuilder stringBuilder = new StringBuilder(str);
stringBuilder.reverse();
System.out.println(stringBuilder.toString()); // !dlroW olleH
```

### Как сравнить значение двух строк

Строка в Java - это отдельный объект, который может не совпадать с другим объектом, хотя на экране результат выводимой строки может выглядеть одинаково. Оператор == (а также !=) работает с ссылками объекта `String`. Если две переменные `String` указывают на один и тот же объект в памяти,сравнение вернет результат `true`. В противном случае результат будет `false`, несмотря на то что текст может содержать в точности такие же символы.
Для сравнения посимвольно на эквивалентность необходимо использовать метод `equals()`.

```Java
String s1 = new String("Hello World!");
String s2 = new String("Hello World!");
String s3 = "Hello World!";
String s4 = "Hello World!";

System.out.println(s1 == s2); // false
System.out.println(s3 == s4); // true, Потому что один набор литералов будет указывать на одну область в памяти
System.out.println(s1.equals(s2)); // true

s1 = s2;
System.out.println(s1 == s2); // true
```

### Как обрезать пробелы в начале и конце строки

С помощью метода `trim()` класса `String`:

```Java
String s = "   Hello   "
System.out.println(s.trim() + "World!") // HelloWorld!
```

### Дайте определение понятию "пул строк"

Пул строк - это набор строк, который хранится в памяти Java Heap. Мы знаем, что `String` это специальный класс в Java, и мы можем создавать объекты этого класса, используя оператор new точно так же, как и создавать объекты, предоставляя значение строки в двойных кавычках.
Диаграмма ниже объясняет, как пул строк размещается в памяти Java Heap и что происходит, когда мы используем различные способы создания строк.

![StringPool](../../assets/JavaCore/stringpool.jpg

Пул строк возможен исключительно благодаря неизменяемости строк в Java и реализации идеи интернирования строк.

Пул строк помогает экономить большой объем памяти, но с другой стороны создание строки занимает больше времени.

Когда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка.

Тем не менее, когда мы используем оператор new, мы принуждаем класс `String` создать новый объект строки, а затем мы можем использовать метод `intern()` для того, чтобы поместить строку в пул, или получить из пула ссылку на другой объект `String` с таким же значением.

### Можно ли синхронизировать доступ к строке

`String` сам по себе потокобезопасный класс. Если мы мы работаем с изменяемыми строками, то нужно использовать `StringBuffer`.

### Почему строка неизменная и финализированная в Java

Есть несколько преимуществ в неизменности строк:

- Строковый пул возможен только потому, что строка неизменна в Java, таким образом виртуальная машина сохраняет много места в памяти(Heap Space), поскольку разные строковые переменные указывают на одну переменную в пуле. Если бы строка не была неизмененяемой, тогда бы интернирование строк не было бы возможным, потому что если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.
- Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в противном случае любой хакер может изменить значение ссылки и вызвать проблемы в безопасности приложения.
- Строки используются в Java ClassLoader и неизменность обеспечивает правильность загрузки класса при помощи ClassLoader. К примеру, задумайтесь об экземпляре класса, когда вы пытаетесь загрузить `java.sql.Connection` класс, но значение ссылки изменено на `myhacked.Connection` класс, который может осуществить нежелательные вещи с вашей базой данных.
- Поскольку строка неизменная, её **HashCode** кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в **Map** и его обработка будет быстрее, чем других ключей **HashMap**. Это причина, почему строка наиболее часто используемый объект, используемый в качестве ключа **HashMap**.

### Напишите метод удаления данного символа из строки

Мы можем использовать метод `replaceAll()` для замены всех вхождений в строку другой строкой. Обратите внимание на то, что метод получает в качестве аргумента строку, поэтому мы используем класс `Character` для создания строки из символа, и используем её для замены всех символов на пустую строку.

```Java
public static String removeChar(String str, char c) {
    return str == null ? null : str.replaceAll(Character.toString(c), "");
}
```

## Для чего используются обобщенные типы в Java

~~Обобщенные типы в Java были изобретены, в первую очередь, для реализации обобщенных коллекций.~~

## Что такое autoboxing (Автоупаковка)

Autoboxing/Unboxing - автоматическое преобразование между скалярными типами Java и соответствующими типами-врапперами (например, между int - Integer). Наличие такой возможности сокращает код, поскольку исключает необходимость выполнения явных преобразований типов в очевидных случаях.

## Приведение типов (Понижение повышение типа) ошибка ClassCastException

Приведение типов - это установка переменной типа отличного от текущего.
В Java есть два типа приведения:

- Автоматическое
- Ручное

Автоматическое происходит следующим образом (!Уточнить)
byte -> short -> int -> long -> float -> double
То есть, если мы расширяем тип, то явное приведение не требуется, в случае когда точность снижается (Например float -> int) то требуется явно указать приведение к типу.
Объекты можно автоматически привести от наследника к родителю, наоборот вызовется исключение `ClassCastException`
