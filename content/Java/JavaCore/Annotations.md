# Что такое Аннотации в Java

Аннотации - это своего рода метатеги, которые добавляются к коду и применяются к объявлению пакетов, классов, конструкторов, методов, полей, параметров и локальных переменных. Аннотации всегда обладают некоторой информацией и связывают эти "дополнительные данные" и все перечисленные конструкции языка.

Фактически аннотации представляют собой их дополнительные модификаторы, применение которых не влечет за собой изменений ранее созданного кода.

## Какие функции выполняет Аннотации

Аннотация выполняет следующие функции:

- Дает необходимую информацию для компилятора;
- Дает информацию различным инструментам для генерации другого кода, конфигураций;
- Может использоваться во время работы кода;

Самая часто встречаемая аннотация, которую встречал любой программист, даже начинающий это `@Override`.

## ~~Какие встроенные аннотации в Java вы знаете~~

В языке Java SE определено несколько встроенных аннотаций, большинство из их являются специализированными. Четыре типа `@Retention`, `@Documented`, `@Target` и `@Inherited` - из пакета `java.lang.annotation`.

Из оставшиеся выделяются - `@Override`, `@Deprecated`, `@SafeVarargs` и `@SuppressWarnings` - из пакета `java.lang.` Широкое использование аннотаций в различных технологиях и фреймворках обуславливается возможностью сокращения кода и снижения его связанности.

### Что делают аннотации `@Retention`, `@Documented`, `@Target` и `@Inherited`

Эти аннотации, имеют следующее значение:

- `@Retention` - эта аннотация предназначена для применения только в качестве аннотации к другим аннотациям, позволяет указать жизненный цикл аннотации: будет она присутствовать только в исходном коде, в скомпилированном файле, или она будет также видна и в процессе выполнения. Выбор нужного типа зависит от того, как вы хотите использовать аннотацию.
- `@Documented` - это маркер-интерфейс, который сообщает инструменту, что аннотация должна быть документирована.
- `@Target` - эта аннотация задает тип объявления, к которым может быть применима аннотация. Принимает один аргумент, который должен быть константой из перечисления ElementType, это может быть поле, метод, тип и т.д. Например,чтобы указать, что аннотация применима только к полям и локальным переменным: @Targer({ ElementType.FIELD, ElementTyle.LOCAL_VARIABLE } )
- `@Inherited` - это аннотация-маркер, которая может применяться в другом объявление аннотации, она касается только тех аннотаций, что будут использованы в объявлениях классов. Эта аннотация позволяет аннотации супер класса быть унаследованной в подклассе.

### Что делают аннотации `@Override`, `@Deprecated`, `@SafeVarargs` и `@SuppressWarnings`

Эти аннотации предназначены для:

- `@Override` - аннотация-маркер, которая может применяться только к методам. Метод, аннотированный как `@Override`, должен переопределять метод супер класса.
- `@Deprecated` - указывает, что объявление устарело и должно быть заменено более новой формой.
- `@SafeVarargs` - аннотация-маркер, применяется к методам и конструкторам. Она указывает, что никакие небезопасные действия, связанные с параметром переменного количества аргументов, недопустимы. Применяется только к методам и конструкторам с переменным количеством аргументов, которые объявлены как `static` или `final`.
- `@SuppressWarnings` - эта аннотация указывает, что одно или более предупреждений, которые могут быть выданы компилятором следует подавить.

### Какой жизненный цикл аннотации можно указать с помощью @Retention

Существует 3 возможные варианты чтобы указать где аннотация будет жить. Они инкапсулированы в перечисление `java.lang.annotation.RetentionPolicy`. Это **SOURSE**, **CLASS**, **RUNTIME**.

- **SOURCE** - содержаться только в исходном файле и отбрасываются при компиляции.
- **CLASS** - сохраняются в файле, однако они недоступны JVM во время выполнения.
- **RUNTIME** - сохраняются в файле во время компиляции и остаются доступными JVM во время выполнения.

### К каким элементам можно применять аннотацию, как это указать

Для того чтобы ограничить использование аннотации её нужно проаннотировать. Для этого существует аннотация `@Target`.

- `@Target(ElementType.PACKAGE)` - только для пакетов
- `@Target(ElementType.TYPE)` - только для классов
- `@Target(ElementType.CONSTRUCTOR)` - только для конструкторов
- `@Target(ElementType.METHOD)` - только для методов
- `@Target(ElementType.FIELD)` - только для атрибутов(переменных) класса
- `@Target(ElementType.PARAMATER)` - только для параметров метода
- `@Target(ElementType.LOCAL_VARIABLE)` - только для локальных переменных

В случае если вы хотите, что бы ваша аннотация использовалась больше чем для одного типа параметров, то можно указать @Target следующим образом:

`@Target({ElementType.PARAMETER, ElementType.LOCAL_VARIABLE})`

Тут мы говорим, аннотацию можно использовать только для параметров метода и для локальных переменных.

## Как создать свою Аннотацию

Написать свою аннотацию не так сложно, как могло бы казаться. В следующем коде приведено объявление аннотации.

```Java
public @interface About {
    String info() default "";
}
```

Как видно на месте где обычно пишут `class` или `interface` у нас написано `@interface`.

Структура практически та же, что и у интерфейсов, только пишется `@interface`.

`@interface` - указывает на то, что это аннотация
`default` - говорит про то, что метод по умолчанию будет возвращать определённое значение.

### ~~Конфигурация аннотаций~~

### Атрибуты каких типов допустимы в аннотациях

Атрибуты могут иметь только следующие типы:

- `String`
- `Class` или «any parameterized invocation of Class»
- `Enum`
- `Annotation`
- Одномерный массив любого из вышеперечисленных типов
