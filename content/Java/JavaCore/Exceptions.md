# Иерархия исключений

Все классы-исключения расширяют класс `Throwable` - непосредственное расширение класса object.
У класса `Throwable` и у всех его расширений по традиции два конструктора:

- `Throwable e` - конструктор по умолчанию
- `Throwable (String message)` - создаваемый объект будет содержать произвольное сообщение `message`

Записанное в конструкторе сообщение можно получить затем методом `getMessage()`. Если объект создавался конструктором по умолчанию, то данный метод возвратит `null`.

Метод `toString()` возвращает краткое описание события, именно он работал в предыдущих листингах.
Три метода выводят сообщения обо всех методах, встретившихся по пути "полета" исключения:

- `printstackTrace()` - выводит сообщения в стандартный вывод, как правило, это консоль
- `printStackTrace(PrintStream stream)` - выводит сообщения в байтовый поток stream
- `printStackTrace(PrintWriter stream)` - выводит сообщения в символьный поток stream

У класса `Throwable` два непосредственных наследника - классы `Error` и `Exception`. Они не добавляют новых методов, а служат для разделения классов-исключений на два больших семейства - семейство классов-ошибок (`Error`) и семейство собственно классов-исключений (`Exception`).

Классы ошибки, расширяющие класс `Error`, свидетельствуют о возникновении сложных ситуаций в виртуальной машине Java. Их обработка требует глубокого понимания всех тонкостей работы JVM. Ее не рекомендуется выполнять в обычной программе. Не советуют даже выбрасывать ошибки оператором throw. He следует делать свои классы-исключения расширениями класса `Error` или какого-то его подкласса.

Имена классов-ошибок, по соглашению, заканчиваются словом `Error`.

Классы-исключения, расширяющие класс `Exception`, отмечают возникновение обычной нештатной ситуации, которую можно и даже нужно обработать. Такие исключения следует выбросить оператором `throw`.

Классов-исключений очень много, более двухсот. Они разбросаны буквально по всем пакетам J2SDK. В большинстве случаев вы способны подобрать готовый класс-исключение для обработки исключительных ситуаций в своей программе. При желании можно создать и свой класс-исключение, расширив класс `Exception` или любой его подкласс.

 Среди классов-исключений выделяется класс `RuntimeException` - прямое расширение класса `Exception`. В нем и его подклассах отмечаются исключения, возникшие при работе JVM, но не столь серьезные, как ошибки. Их можно обрабатывать и выбрасывать, расширять своими классами, но лучше доверить это JVM, поскольку чаще всего это просто ошибка в программе, которую надо исправить. Особенность исключений данного класса в том, что их не надо отмечать в заголовке метода пометкой `throws`.
 Имена классов-исключений, по соглашению, заканчиваются словом `Exception`.

## Какие есть виды исключений в Java, чем они отличаются

Все исключительные ситуации можно разделить на две категории: проверяемые(**checked**) и непроверяемые(**unchecked**).

Все исключения, порождаемые от `Throwable`, можно разбить на три группы. Они определяются тремя базовыми типами: наследниками `Throwable` - классами `Error` и `Exception`, а также наследником `Exception` - `RuntimeException`.

Ошибки, порожденные от `Exception` (и не являющиеся наследниками `RuntimeException`), являются проверяемыми, во время компиляции проверяется, предусмотрена ли обработка возможных исключительных ситуаций. Как правило, это ошибки, связанные с окружением программы (сетевым, файловым вводом-выводом и др.), которые могут возникнуть вне зависимости от того, корректно написан код или нет. Например, открытие сетевого соединения или файла может привести к возникновению ошибки и компилятор требует от программиста предусмотреть некие действия для обработки возможных проблем. Таким образом повышается надежность программы, ее устойчивость при возможных сбоях.

Исключения, порожденные от `RuntimeException`, являются непроверяемыми и компилятор не требует обязательной их обработки.

Как правило, это ошибки программы, которые при правильном кодировании возникать не должны (например, `IndexOutOfBoundsException` - выход за границы массива, `java.lang.ArithmeticException` - деление на ноль). Поэтому, чтобы не загромождать программу, компилятор оставляет на усмотрение программиста обработку таких исключений с помощью блоков `try-catch`.

Исключения, порожденные от `Error`, также не являются проверяемыми. Они предназначены для того, чтобы уведомить приложение о возникновении фатальной ситуации, которую программным способом устранить практически невозможно (хотя формально обработчик допускается). Они могут свидетельствовать об ошибках программы, но, как правило, это неустранимые проблемы на уровне JVM. В качестве примера можно привести `StackOverflowError` - (переполнение стека), `OutOfMemoryError` - (нехватка памяти).

Методы, код которых может порождать проверяемые исключения, должны либо сами их обрабатывать, либо в заголовке метода должно быть указано ключевое слово `throws` с перечислением необрабатываемых проверяемых исключений. На непроверяемые ошибки это правило не распространяется.
Переопределенный (**overridden**) метод не может расширять список возможных исключений исходного метода.

### Что такое Checked и Unchecked Exception

**Checked** исключения, это те, которые должны обрабатываться блоком `catch` или описываться в сигнатуре метода. **Unchecked** могут не обрабатываться и не быть описанными.

**Unchecked** исключения в Java - наследованные от `RuntimeException`, **Checked** - от `Exception`.
Пример: **Unchecked** исключения - `NullPointerException`, **Checked** исключения - `IOException`.

### Какие есть Unchecked Exeption

- `ArithmeticException` - Арифметическая ошибка: деление на ноль
- `ArrayIndexOutOfBoundsException` - Индекс выходит за пределы массива
- `ArrayStoreException` - Присвоение элементу массива значения несовместимого типа
- `ClassCastException` - Недопустимое приведение к типу
- `ConcurrentModificationException` - Некорректная модификация коллекции
- `IllegalArgumentException` - При вызове метода ипользован неправильный аргумент
- `IllegalMonitorStateException` - ~~Неверная операция на экземпляре~~
- `IllegalStateException` - ~~Среда или приложение находятся в некорректном состоянии~~
- `IllegalThreadStateException` - ~~Операция не совместима с текущим состоянием потока~~
- `IndexOutOfBoundsException` - ~~Индекс выходит за пределы~~
- `NegativeArraySizeException` - Массив был создан с отрицательным размером
- `NullPointerException` - Недопустимое использование нулевой ссылки
- `NumberFormatException` - Невозможно преобразовать строку в числовой формат
- `StringIndexOutOfBoundsException` - Индекс выходит за пределы строки
- `UnsupportedOperationException` - Неподдерживаемая операция

### Что такое `Error`

Исключения, порожденные от `Error`, не являются проверяемыми. Они предназначены для того, чтобы уведомить приложение о возникновении фатальной ситуации, которую программным способом устранить практически невозможно (хотя формально обработчик допускается). Они могут свидетельствовать об ошибках программы, но, как правило, это неустранимые проблемы на уровне JVM. В качестве примера можно привести `StackOverflowError` (переполнение стека), `OutOfMemoryError` (нехватка памяти).

Методы, код которых может порождать проверяемые исключения, должны либо сами их обрабатывать, либо в заголовке метода должно быть указано ключевое слово throws с перечислением необрабатываемых проверяемых исключений. На непроверяемые ошибки это правило не распространяется.

### ~~Что такое `Exception`~~

### Принцип работы блока try-catch-finally

Если срабатывает один из блоков `catch`, то остальные блоки в данной конструкции `try-catch` выполняться не будут.

Cвойством транзакционности исключения не обладают - действия, произведенные в блоке `try` до возникновения исключения, не отменяются поcле его возникновения.

#### Возможно ли использование блока `try-finally` (без `catch`)

`try` может быть в паре с `finally`, без `catch`. Работает это точно так же - после выхода из блока `try` выполняется блок `finally`. Это может быть полезно, например, в следующей ситуации.

При выходе из метода вам надо произвести какое-либо действие. А `return` в этом методе стоит в нескольких местах. Писать одинаковый код перед каждым `return` нецелесообразно. Гораздо проще и эффективнее поместить основной код в `try`, а код, выполняемый при выходе - в `finally`.

#### Всегда ли исполняется блок finally

Не всегда например в следующих ситуациях:

- Существуют потоки-демоны - потоки предоставляющие некие сервисы, работая в фоновом режиме во время выполнения программы, но при этом не являются ее неотъемлеммой частью.Таким образом когда все потоки не демоны завершаются, программа завершает свою работу. В потоках демонах блок `finally` не выполняеться, они прерываются внезапно.
- `System.exit(0)`
- Если в блоке `finally` произошло исключение и нет обработчика, то оставшийся код в блоке `finally` может не выполнятся.
