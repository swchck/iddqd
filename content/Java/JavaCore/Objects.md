# Objects

## Какие методы есть у класса Object

~~Object это базовый класс для всех остальных объектов в Java. Каждый класс наследуется от Object. Соответственно все классы наследуют методы класса Object.~~(!Уточнить)
Методы класса Object:

- public final native Class getClass()
- public native int hashCode()
- public boolean equals(Object obj)
- protected native Object clone() throws CloneNotSupportedException
- public String toString()
- public final native void notify()
- public final native void notifyAll()
- public final native void wait(long timeout) throws InterruptedException
- public final void wait(long timeout, int nanos) throws InterruptedException
- public final void wait() throws InterruptedException
- protected void finalize() throws Throwable

## Правила переопределения метода Object.equals()

- Используйте оператор == что бы проверить ссылку на объект, переданную в метод equals. Если ссылки совпадают - вернуть true. Это не обязательно, нужно скорее для оптимизации, но может сэкономить время в случае "тяжёлых" сравнений.
- Используйте оператор instanceof для проверки типа аргумента. Если типы не совпадают, вернуть false.
- Преобразуйте аргумент к корректному типу. Так как на предыдущем шаге мы выполнили проверку, преобразование корректно.
- Пройтись по всем значимым полям объектов и сравнить их друг с другом. Если все поля равны - вернуть true. Для сравнения простых типов использовать ==. Для полей со ссылкой на объекты использовать equals, float преобразовывать в int с помощью Float.floatToIntBits и сравнить с помощью ==, double преобразовывать в long с помощью Double.doubleToLongBits и сравнить с помощью ==. Для коллекций вышеперечисленные правила применяются к каждому элементу коллекции. Нужно учитывать возможность null полей/объектов. Очерёдность сравнения полей может существенно влиять на производительность.
- Закончив реализацию equals задайте себе вопрос, является ли метод симметричным, транзитивным и не противоречивым.

И ещё несколько дополнительных правил:

- Переопределив equals, всегда переопределять hashCode
- Не использовать сложную семантику в equals (типа определения синонимов), equals должен сравнивать поля объектов, не более.

### Какие условия должны удовлетворяться для переопределенного метода equals()

Метод equals() обозначает отношение эквивалентности объектов. Эквивалентным называется отношение, которое является симметричным, транзитивным и рефлексивным.

- Рефлексивность: для любого ненулевого x, x.equals(x) вернет true
- Транзитивность: для любого ненулевого x, y и z, если x.equals(y) и y.eqals(z) вернет true, тогда и x.equals(z) вернет true
- Симметричность: для любого ненулевого x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) вернет true

Также для любого ненулевого x, x.equals(null) должно вернуть false.

## Какая связь между hashCode и equals

Объекты равны, когда `a.equals(b)=true и a.hashCode==b.hashcode -> true` Но необязательно, чтобы два различных объекта возвращали различные хэш-коды(такая ситуация называется коллизией).

### Каким образом реализованы методы hashCode и equals в классе Object

Реализация метода equals в классе Object сводится к проверке на равенство двух ссылок:

```Java
public boolean equals(Object obj) {
    return (this == obj);
}
```

Реализация же метода hashCode класса Object сделана нативной, т.е. определенной не с помощью Java кода:

`public native int hashCode();`

Он обычно возвращает адрес объекта в памяти.

### Что будет, если переопределить equals не переопределяя hashCode? Какие могут возникнуть проблемы

Они будут неправильно хранится в контейнерах, использующих хэш коды, таких как HashMap, HashSet.
Например HashSet хранит элементы в случайном (на первый взгляд) порядке. Дело в том, что для быстрого поиска HashSet рассчитывает для каждого элемента hashCode и именно по этому ключу ищет и упорядочивает элементы внутри себя

### Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode

Необходимо использовать уникальные, лучше примитивные поля, такие как id, uuid, например. Причем если эти поля задействованы при вычислении hashCode, то нужно их задействовать при выполнении equals.
Общий совет: выбирать поля, которые с большой долью вероятности будут различаться.

### Для чего нужен метод `hashCode()`

Существуют коллекции(HashMap, HashSet), которые используют хэш код, как основу при работе с объектами. А если хэш для равных объектов будет разным, то в HashMap будут два равных значения, что является ошибкой. Поэтому необходимо соответствующим образом переопределить метод hashCode().

- Хеширование - преобразование входного массива данных произвольной длины в выходную битовую строку фиксированной длины. Такие преобразования также называются хеш-функциями или функциями свёртки, а их результаты называют хешем или хеш-кодом.
- Хеш-таблицы - это структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары (ключ, значение) и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу.

Выполнение операции в хеш-таблице начинается с вычисления хеш-функции от ключа. Получающееся хеш-значение `i = hash(key)` играет роль индекса в массиве H. Затем выполняемая операция (добавление, удаление или поиск) перенаправляется объекту, который хранится в соответствующей ячейке массива `H[i]`.
Одним из методов построения хеш-функции есть метод деления с остатком (division method) состоит в том, что ключу k ставится в соответствие остаток от деления k на m, где m - число возможных хеш-значений.

### Правила переопределения метода Object.hashCode()

При реализации hashCode используется несколько простых правил. Прежде всего, при вычислении хеш-кода следует использовать те же поля, которые сравниваются в equals. Это, во-первых, даст равенство хеш-кодов для равных обектов, во-вторых, распределено полученное значение будет точно так же, как и исходные данные. Теоретически, можно сделать так, чтобы хеш-код всегда был равен 0, и это будет абсолютно легальная реализация. Другое дело, что ее ценность будет равна тому же самому нулю.
Несмотря на то, что хеш-коды равных объектов должны быть равны, обратное неверно! Два неравных объекта могут иметь равные хеш-коды. Решающее значение имеет не уникальность, а скорость вычисления, потому как это приходится делать очень часто. Потому, в некоторых случаях имеет смысл посчитать хеш-код заранее и просто выдавать его по запросу. Прежде всего это стоит делать тогда, когда вычисление трудоемко, а объект неизменен.

### Клонирование объектов. В чем отличие между поверхностным и глубоким клонированием

Чтобы объект можно было клонировать, он должен реализовать интерфейс ~~Cloneable(маркер)~~. Использование этого интерфейса влияет на поведение метода `clone()` класса Object. Таким образом `myObj.clone()` создаст нам клон нашего объекта, но этот клон будет поверхностный.
Что значит поверхностным? Это значит что клонируется только примитивные поля класса, ссылочные поля клонироваться не будут!

Для того, чтоб произвести глубокое клонирование, необходимо в клонируемом классе переопределить метод `clone()`, и в нем произвести клонирование изменяемых полей объекта.

### Правила переопределения метода `Object.clone()`

Метод `clone()` в Java используется для клонирования объектов. Так как Java работает с объектами с помощью ссылок, то простым присваиванием тут не обойдешься, ибо в таком случае копируется лишь адрес, и мы получим две ссылки на один и тот же объект, а это не то что нам нужно. Механизм копирования обеспечивает метод `clone()` класса `Object`.

Метод `clone()` действует как конструктор копирования. Обычно он вызывает метод `clone()` суперкласса и т.д. пока не дойдет до `Object`.

Метод `clone()` класса `Object` создает и возвращает копию объекта с такими же значениями полей. `Object.clone()` кидает исключение `CloneNotSupportedException` если вы пытаетесь клонировать объект не реализующий интерфейс `Cloneable`. Реализация по умолчанию метода `Object.clone()` выполняет неполное/поверхностное (shallow) копирование. Если вам нужно полное/глубокое (deep) копирование класса, то в методе `clone()` этого класса, после получения клона суперкласса, необходимо скопировать нужные поля.

Синтаксис вызова `clone()` следующий:

```Java
Object copy = obj.clone();

// Или

MyClass copy = (MyClass) obj.clone();
```

Один из недостатков метода `clone()`, это тот факт, что возвращается тип `Object`, поэтому требуется нисходящее преобразование типа. Однако начиная с версии Java 1.5 при переопределении метода вы можете сузить возвращаемый тип.

Пару слов о `clone()` и `final` полях.
Метод `clone()` несовместим с `final` полями. Если вы попробуете клонировать `final` поле компилятор остановит вас. Единственное решение - отказаться от `final`.

### Где и как можно использовать закрытый конструктор

Например в качестве паттерна `Singleton`. В том же классе создается статический метод. Где и создается экземпляр класса, конечно если он уже не создан, тогда он просто возвращается методом.

### Что такое конструктор по умолчанию

В Java если нет явным образом опредёленных конструкторов в классе, то компилятор использует конструктор по умолчанию, опредёленный неявным способом, который аналогичен "чистому", конструктору по умолчанию. Конструктор по умолчанию - это довольно простая конструкция, которая сводится к созданию для типа конструктора без параметров. Так, например, если при объявлении нестатического класса не объявить пользовательский конструктор, (не важно, с параметрами или без них), то компилятор самостоятельно сгенерирует конструктор без параметров. Некоторые программисты явным образом задают конструктор по умолчанию по привычке, чтобы не забыть в дальнейшем, но это не обязательно.

В Java если производный класс не вызывает явным образом конструктор базового класса (в Java используя `super()` в первой строчке), то конструктор по умолчанию вызывается неявно. Если базовый класс не имеет конструктора по умолчанию, то это считается ошибкой.

## Может ли объект получить доступ к private переменной класса

Доступ у приватной переменной класса можно получить только внутри класса, в котором она объявлена. Также доступ к приватным переменным можно осуществить через механизм Java Reflection API.
