# Java Concurrency

## Что такое процесс

Процесс — это совокупность кода и данных, разделяющих общее виртуальное адресное пространство. Процессы изолированы друг от друга, поэтому прямой доступ к памяти чужого процесса невозможен (взаимодействие между процессами осуществляется с помощью специальных средств). Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.

## Что такое поток (Thread)

Один поток («нить» или «трэд») – это одна единица исполнения кода. Каждый поток последовательно выполняет инструкции процесса, которому он принадлежит, параллельно с другими потоками этого процесса.

## Что такое синхронизация потоков

Синхронизация относится к многопоточности. Синхронизированный блок кода может быть выполнен только одним потоком одновременно.

Java поддерживает несколько потоков для выполнения. Это может привести к тому, что два или более потока получат доступ к одному и тому же полю или объекту. Синхронизация — это процесс, который позволяет выполнять все параллельные потоки в программе синхронно. Синхронизация позволяет избежать ошибок согласованности памяти, вызванных непоследовательным доступом к общей памяти.
Когда метод объявлен как синхронизированный — нить держит монитор для объекта, метод которого исполняется. Если другой поток выполняет синхронизированный метод, ваш поток заблокируется до тех пор, пока другой поток не отпустит монитор.
Синхронизация достигается в Java использованием зарезервированного слова synchronized. Вы можете использовать его в своих классах определяя синхронизированные методы или блоки. Вы не сможете использовать synchronized в переменных или атрибутах в определении класса.

## Cпособы синхронизации в Java

Ниже приведены некоторые способы синхронизации в Java:

- Системная синхронизация с использованием wait/notify. Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait, предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод notify (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток "просыпается" и продолжает свое выполнение.
- Системная синхронизация с использованием join. Метод join, вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, как поток, связаный с этим экземпляром, закончит работу.
- Использование классов из пакета java.util.concurrent, который предоставляет набор классов для организации межпоточного взаимодействия. Примеры таких классов - Lock, семафор (Semaphore), etc. Концепция данного подхода заключается в использовании атомарных операций и переменных.

## На каком объекте происходит синхронизация при вызове static synchronized метода

Представьте себе ситуацию что два потока одновременно изменяют состояние какого-то объекта, это недопустимо. Для этого необходимо синхронизировать потоки. Как это сделать? Ключевое слово synchronized позволяет это сделать установив в сигнатуре метода. Или же в методе можно описать блок synchronized, только в качестве параметра необходимо передать объект, который будет блокироватся.
Представьте себе ситуацию когда один поток ждет пока разблокируется объект… а если это ждут несколько потоков? Нет гарантии что тот объект что больше всех ждал снятия блокировки будет выполнятся первым.
Статические синхронизированные методы и нестатические  синхронизированные методы не будет  блокировать друг друга, никогда. Статические  методы блокируются на экземпляре класса Class в то время как нестатические методы блокируются на текущем экземпляре (this). Эти действия не мешают друг другу.
wait() - отказывается от блокировки остальные методы сохраняют блокировку.

## В каких случаях целесообразно создавать несколько потоков

Многопоточные приложения применяются в случаях, когда можно разделить программу на несколько относительно независимых частей. В этом случае чтобы один код не ждал другой их помещают в различные потоки. В качестве примера можно привести программу с графическим интерфейсом — пока выполняются какие-либо длительные вычисления в одном потоке, интерфейс может быть доступен пользователю и не зависать, если он выполняется в другом потоке.

## Что может произойти если два потока будут выполнять один и тот же код

Если используются не синхронизированные данные, то может произойти ситуация, когда код работает уже с устаревшими данными. Например, в первом потоке идет изменение каких-либо полей, а в это время второй поток читает эти поля.

## Какие есть способы создания и запуска потоков

Существует несколько способов создания и запуска потоков.

С помощью класса, реализующего `Runnable`

- Создать объект класса `Thread`.
- Создать объект класса, реализующего интерфейс `Runnable`
- Вызвать у созданного объекта `Thread` метод `start()` (после этого запустится метод `run()` у переданного объекта, реализующего `Runnable`)

С помощью класса, расширяющего `Thread`

- Создать объект класса `ClassName extends Thread`.
- Переопределить `run()` в этом классе (смотрите пример ниже, где передается имя потока ‘Second’)

С помощью класса, реализующего `java.util.concurrent.Callable`

- Создать объект класса, реализующего интерфейс `Callable`
- Создать объект `ExecutorService` с указанием пула потоков.
- Создать объект `Future`. Запуск происходит через метод `submit()`;
  
Сигнатура: `<T> Future<T> submit(Callable<T> task)`

```java
public static void howToRunThreads() {
        ThreadClass threadClass = new ThreadClass("First");
        threadClass.start(); //method ThreadClass.run()

        Thread thread = new Thread(new RunnableClass("Second"));
        Thread thread2 = new Thread(new RunnableClass("Third"));
        Thread thread3 = new Thread(new RunnableClass("Fourth"));
        thread.start(); //method RunnableClass.run()
        thread2.start(); //method RunnableClass.run()
        thread3.start(); //method RunnableClass.run()
    }

public class RunnableClass implements Runnable {

    private String localName;

    public RunnableClass() {
    }

    public RunnableClass(String localName) {
        this.localName = localName;
    }

    @Override
    public void run() {
        System.out.println("run() " + localName + " running");
    }

    public String getLocalName() {return localName;}
    public void setLocalName(String localName) {this.localName = localName;}
}

public class ThreadClass extends Thread {

    public ThreadClass() {
    }

    public ThreadClass(String name) {
        super(name);
    }

    public ThreadClass(Runnable target) {
        super(target);
        System.out.println(target + " will running");
    }

    @Override
    public void run() {
         System.out.println("ThreadClass run() method " + "Thread name is: " + this.getName());
    }
}
//Вывод
ThreadClass run() method Thread name is: First
run() Third running
run() Fourth running
run() Second running //обратите внимание, поменялись местами при выполнении.
```

Пример с интерфейсом `Callable`:

```java
public class CallableExample {

  public static class WordLengthCallable
        implements Callable {
    private String word;
    public WordLengthCallable(String word) {
      this.word = word;
    }
    public Integer call() {
      return Integer.valueOf(word.length());
    }
  }

  public static void main(String args[]) throws Exception {
    ExecutorService pool = Executors.newFixedThreadPool(3);
    Set<Future<Integer>> set = new HashSet<Future<Integer>>();
    for (String word: args) {
      Callable<Integer> callable = new WordLengthCallable(word);
      Future<Integer> future = pool.submit(callable);
      set.add(future);
    }
    int sum = 0;
    for (Future<Integer> future : set) {
      sum += future.get();
    }
    System.out.printf("The sum of lengths is %s%n", sum);
    System.exit(sum);
  }
}
```

## Как принудительно остановить поток

В Java 8 нет метода, который бы принудительно останавливал поток. Никто не гарантирует, что нить можно остановить. Она может остановиться только сама. Java имеет встроенный механизм оповещения потока, который называется Interruption (прерывание, вмешательство).

Класс Thread содержит в себе скрытое булево поле, которое называется флагом прерывания. Установить этот флаг можно вызвав метод interrupt() потока. Проверить же, установлен ли этот флаг, можно двумя способами. Первый способ — вызвать метод bool isInterrupted() объекта потока, второй — вызвать статический метод bool Thread.interrupted(). Первый метод возвращает состояние флага прерывания и оставляет этот флаг нетронутым. Второй метод возвращает состояние флага и сбрасывает его. Заметьте что Thread.interrupted() — статический метод класса Thread, и его вызов возвращает значение флага прерывания того потока, из которого он был вызван. Поэтому этот метод вызывается только изнутри потока и позволяет потоку проверить своё состояние прерывания.

У методов, приостанавливающих выполнение потока, таких как sleep(), wait() и join() есть одна особенность — если во время их выполнения будет вызван метод interrupt() этого потока, они, не дожидаясь конца времени ожидания, сгенерируют исключение InterruptedException.

```java
public class JoinClass implements Runnable {

    @Override
    public void run() {
        for (int i=0; i<100; i++) {
            if(!Thread.interrupted()) {
                System.out.println(i);
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    System.out.println("InterruptedException!");
                    System.err.println("Exception msg: " + e.getMessage());
                    return;
                }
            } else {
                System.out.println("Interrupted!");
                return;
            }
        }
    }
}
public class TestClass {

    public static void main(String[] args) {
        Thread thread = new Thread(new JoinClass());
        thread.start();
        try {
            Thread.sleep(1000L); // выключаем поток main, чтобы в JoinClass.run() что-то успело посчитаться
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread.interrupt();
    }
}
//Вывод
0
1
...
8
9 //счетчик был до 100
InterruptedException!
Exception msg: sleep interrupted
```

- В методе `main()` создаем объект класса `JoinClass` и запускаем его методом `run()`. Сначала проверяется не завершен ли уже этот поток, а затем каждые 100мс выводится значение счетчика.
- Главному методу приказывает подождать 1000мс, чтобы счетчик успел немножко посчитать.
- Вызываем `interrupt` метод у объекта класса `JoinClass`. После этого в цикле сразу ловится исключение и срабатывает return в блоке `catch`.

## Что такое демон (Daemon)

Потоками-демонами называются потоки, работающие в фоновом режиме для нашей программы.

В Java процесс завершается тогда, когда завершается последний его поток. Даже если метод main() уже завершился, но еще выполняются порожденные им потоки, система будет ждать их завершения.
Однако это правило не относится к особому виду потоков – демонам. Если завершился последний обычный поток процесса, и остались только потоки-демоны, то они будут принудительно завершены и выполнение процесса закончится. Чаще всего потоки-демоны используются для выполнения фоновых задач, обслуживающих процесс в течение его жизни.

## Как создать поток демон

Объявить поток демоном достаточно просто — нужно перед запуском потока вызвать его метод `setDaemon(true)`;
Проверить, является ли поток демоном, можно вызвав его метод `boolean` `isDaemon()`;

```java
Thread thread = new Thread(new DaemonClass());
thread.setDaemon(true);
System.out.println(thread.isDaemon()); //true
```

## Что такое монитор (Mutex)

Несколько нитей могут мешать друг другу при обращении к одним и тем же данным. Для решения этой проблемы придуман мьютекс (он же монитор). Он имеет два состояния — объект занят и объект свободен. Монитор(мьютекс) — высокоуровневый механизм взаимодействия и синхронизации потоков, обеспечивающий доступ к неразделяемым ресурсам.

Когда какой-то нити нужен общий для всех нитей объект, она проверяет мьютекс, связанный с этим объектом. Если мьютекс свободен, то нить блокирует его (помечает как занятый) и начинает использование общего ресурса. После того, как она сделала свои дела, мьютекс разблокируется (помечается как свободен).

Если же нить хочет использовать объект, а мьютекс заблокирован, то нить засыпает в ожидании. Когда мьютекс, наконец, освободится занятой нитью, наша нить тут же заблокирует его и приступит к работе. Мьютекс встроен в класс `Object` и следовательно он есть у каждого объекта.

Когда одна нить заходит внутрь блока кода, помеченного словом `synchronized`, то Java-машина тут же блокирует мьютекс у объекта, который указан в круглых скобках после слова `synchronized`. Больше ни одна нить не сможет зайти в этот блок, пока наша нить его не покинет. Как только наша нить выйдет из блока, помеченного `synchronized`, то мьютекс тут же автоматически разблокируется и будет свободен для захвата другой нитью. Если же мьютекс был занят, то наша нить будет стоять на месте и ждать когда он освободится.

## Как приостановить выполнение потока

`Thread.sleep()` — статический метод класса `Thread`, который приостанавливает выполнение потока, в котором он был вызван. Во время выполнения метода `sleep()` система перестает выделять потоку процессорное время, распределяя его между другими потоками. Метод `sleep()` может выполняться либо заданное кол-во времени (миллисекунды или наносекунды) либо до тех пор пока он не будет остановлен прерыванием (в этом случае он сгенерирует исключение `InterruptedException`).

Возможен вопрос про старые методы `suspend`, `stop` и `resume` — они `deprecated`.

## Жизненный цикл потока в Java

![Thread LifeLine](/content/assets/JavaCore/threadLifeLine.png)

- Новый;
- Готовый к выполнению;
- Выполняемый;
- Ожидающий;
- Остановленный.

---

- Новый: в этой фазе поток создается с помощью класса Thread. Он остается в этом состоянии, пока программа его не запустит;
- Готовый к выполнению: экземпляр потока вызывается с помощью метода Start. Управление потоком предоставляется планировщику для завершения выполнения. От планировщика зависит то, следует ли запускать поток;
- Выполняемый: с началом выполнения потока его состояние изменяется на «выполняемый». Планировщик выбирает один поток из пула потоков и начинает его выполнение в приложении;
- Ожидающий: поток ожидает своего выполнения. Поскольку в приложении выполняется сразу несколько потоков, необходимо синхронизировать их. Следовательно, один поток должен ожидать, пока другой поток не будет выполнен. Таким образом, это состояние называется состоянием ожидания;
- Остановленный: выполняемый поток после завершения процесса переходит в состояние «остановленный», известное также как «мертвый».

## В каких состояниях может быть поток

Поток может быть в следующем состоянии: созданный, запущенный, блокированный, остановленный, в режиме ожидания, в режиме ожидания по времени (NEW, RUNNABLE, BLOCKED, TERMINATED, WAITING, TIMED_WAITING).

## Какова функциональность методов notify и notifyAll

Метод notify пробуждает один из потоков, который вызвал метод wait() у этого монитора. Метод notifyAll пробуждает все потоки. Очередность выполнения в этом случае будет определяться приоритетом потока.

```java
public class NotifyClass {

    private List synchedList;

    public NotifyClass() {
        // create a new synchronized list to be used
        synchedList = Collections.synchronizedList(new LinkedList());
    }

    // method used to remove an element from the list
    public String removeElement() throws InterruptedException {
        synchronized (synchedList) {
            // while the list is empty, wait
            while (synchedList.isEmpty()) {
                System.out.println("List is empty...");
                synchedList.wait();
                System.out.println("Waiting...");
            }
            String element = (String) synchedList.remove(0);

            return element;
        }
    }

    // method to add an element in the list
    public void addElement(String element) {
        System.out.println("Opening...");
        synchronized (synchedList) {
            // add an element and notify all that an element exists
            synchedList.add(element);
            System.out.println("New Element:'" + element + "'");

            synchedList.notifyAll();
            System.out.println("notifyAll called!");
        }
        System.out.println("Closing...");
    }

    public static void main(String[] args) {
        final NotifyClass demo = new NotifyClass();

        Runnable runA = new Runnable() {

            public void run() {
                try {
                    String item = demo.removeElement();
                    System.out.println("" + item);
                } catch (InterruptedException ix) {
                    System.out.println("Interrupted Exception!");
                } catch (Exception x) {
                    System.out.println("Exception thrown.");
                }
            }
        };

        Runnable runB = new Runnable() {

            // run adds an element in the list and starts the loop
            public void run() {
                demo.addElement("Hello!");
            }
        };

        try {
            Thread threadA1 = new Thread(runA, "A");
            threadA1.start();

            Thread.sleep(500);

            Thread threadA2 = new Thread(runA, "B");
            threadA2.start();

            Thread.sleep(500);

            Thread threadB = new Thread(runB, "C");
            threadB.start();

            Thread.sleep(1000);

            threadA1.interrupt();
            threadA2.interrupt();
        } catch (InterruptedException x) {
        }
    }

}
//Вывод
List is empty...
List is empty...
Opening...
New Element:'Hello!'
notifyAll called!
Closing...
Waiting...
Waiting...
List is empty...
Hello!
Interrupted Exception!
```

## Что делает метод `join()`

Одна нить (поток) может вызвать метод join() у другой нити. В результате первый поток (который вызвал метод) приостанавливает свою работу и ждет окончания работы второго потока (у объекта которого был вызван метод join()).

Пример:

После запуска метода main создается главный поток класса TestClass.

- Затем мы создаем тестовый поток threadExample и запускаем его.Заставляем поток протупить 5 секунд внутри метода JoinClass.run().
- После чего вызываем метод join() у второго потока. В этот момент главный поток подсоединяется к нашему второму потоку и ждет его завершения.
- Смотрим какое прошло время — 5 секунд. Т.е. главный поток ждал пока завершится threadExample до перехода к методу System.out.println(). В противном случае System.out.println(«END: «) выполнился сразу без ожидания пока отойдет threadExample.

## Что такое volatile

Помещение модификатора `volatile` перед определением переменной заставляет принудительно всегда читать и писать значение только в обычную (медленную) память (а не кэшировать). Записывается как: `private volatile boolean varName;`

## Что такое ThreadGroup

ThreadGroup представляет собой набор нитей, которые так же могут содержать в себе другие группы потоков. Группа нитей образует дерево, в котором каждая другая группа нитей имеет родителя (кроме исходной). Поток имеет право доступа к данным из своей группы нитей, но не имеет такого доступа к другим группам или к родительской группе потоков.

## Что такое ThreadPool

Пулы потоков (нитей) представляют собой управляемую коллекцию потоков, которые доступны для выполнения различных задач. Пулы нитей, как правило, обеспечивают:

Повышение производительности при выполнении большого количества задач в связи с сокращением накладных расходов на вызов каждой задачи.
Является средством ограничивающим расход ресурсов при выполнении набора задач.
Избавляют от необходимости управления жизненным циклом нитей.

## Что такое ThreadPoolExecutor

ThreadPoolExecutor — реализация ExecutorService. Он выполняет переданную задачу (Callable или Runnable), используя одну из внутренних доступных нитей из пула. Пул потоков содержит в себе ThreadPoolExecutor, который может содержать изменяющееся число нитей. Число нитей в пуле задается с помощью corePoolSize и maximumPoolSize.

## Что такое «атомарные типы» в Java

Все атомарные классы переменных имеют базовый элемент Сравнение и назначение (compare-and-set) (аналогичный элементу Сравнение и замена), который реализуется при помощи самого быстрого собственного структурного компонента, который имеется в платформе (Сравнение и замена, Загрузить в связке, Сохранить при условии или в крайнем случае спин-блокировками). В пакет java.util.concurrent.atomic входят 9 видов атомарных переменных (AtomicInteger; AtomicLong; AtomicReference; AtomicBoolean; формы для массивов атомарных целых чисел; длинные (long); ссылки; а также атомарные с пометкой Класс эталона (reference), которые атомарно обновляют две величины).
Классы атомарных переменных можно рассматривать как обобщение volatile переменных, если расширить понятие изменяемых переменных до переменных с поддержкой атомарных обновлений методом Сравнение и назначение. Чтение и запись атомарных переменных имеет такую же семантику памяти как доступ к чтению и записи изменяемых переменных.

## Чем отличаются два интерфейса для реализации задач `Runnable` и `Callable`

Основные различия:

- Интерфейс `Runnable` появиля в Java 1.0, а интерфейс `Callable` был введен в Java 5.0 в составе библиотеки `java.util.concurrent`.
- Классы, реализующие  интерфейс Runnable должны реализовывать метод `run()` для выполнения задачи. Классы, реализующие интерфейс `Callable` должны реализовывать метод `call()` для выполнения задачи.
- Метод `Runnable.run()` не возвращает никакого значения, его тип void, а метод `Callable.call()` может возвращать значение типа T. Интерфейс Callable является параметризированным  `Callable<T>` и тип значения, которое будет возвращаться в методе `call()` задается этим параметром T.
- Метод run() не может бросить проверяемое исключение, в то время как метод call() может бросить проверяемое исключение.

## Различия между CyclicBarrier и CountDownLatch

Хоть оба эти синхронизаторы позволяют нитям дожидаться друг друга, главное различие между ними в том, что вы не можете заново использовать CountDownLatch после того, как его счётчик достигнет нуля, но вы можете использовать CyclicBarrier снова, даже после того, как барьер сломается.

## Что происходит, когда в треде появляется исключение

Это один из хороших вопросов с подвохом. Простыми словами, если исключение не поймано - нить мерта, если установлен обработчик непойманных исключений, он получит колбек. Thread.UncaughtExceptionHandler – интерфейс, определённый как вложенный интерфейс для обработчиков, вызываемых, когда нить внезапно останавливается из-за непойманного исключения. Когда нить собирается остановится из-за непойманного исключения, JVM проверит её на наличие UncaughtExceptionHandler, используя Thread.getUncaughtExceptionHandler(), и вызовет у обработчика метод uncaughtException(), передав нить и исключение в виде аргументов.

## Что такое ReadWriteLock

В целом, ReadWriteLock - это результат техники разбора lock'а для улучшения производительности параллельных приложений. Это интерфейс, который был добавлен в Java 5. Он оперирует парой связанных lock’ов, один для операций чтения, один для записи. Читающий lock может удерживаться одновременно несколькими читающими нитями, до тех пор пока не будет записывающих. Записывающий lock эксклюзивен. Если хотите, вы можете реализовать интерфейс с вашим набором правил, или вы можете использовать ReentrantReadWriteLock, который поддерживает максимум 65535 рекурсивных записывающих lock'ов и 65535 читающих lock'ов.

## Дедлок (Deadlock)

Deadlock (взаимная блокировка) - состояние, при котором несколько потоков находятся в режиме ожидания ресурсов, занятых этими потоками. Работа потоков приостанавливается и программа "зависает".

Пример: Объект А содержит метод "проверить объект Б", объект Б содержит метод "проверить объект А". Оба метода синхронизированы и перед началом работы также пытаются синхронизироваться по объекту, который нужно проверить. Поток 1 вызывает метод объекта А, получая блокировку по объекту А; в этот же самый момент поток 2 вызывает метод объекта Б, получая блокировку по нему. Оба метода пытаются получить блокировку по другому объекту и входят в режим ожидания. Оба потока останавливаются. Deadlock.

Главный способ борьбы со взаимной блокировкой - синхронизация по объектам в одном и том же порядке. Оба потока должны в первую очередь проверять один и тот же объект.

В нашем примере: можно переписать метод в объекте Б так, чтобы он сам не был синхронизированным, в начале работы получал блокировку по объекту А, а уже потом по объекту Б. Тогда второй поток встанет в ожидание ещё до вызова метода и работа завершится успешно.

Взаимная блокировка - это ошибка, которая происходит когда потоки имеют циклическую зависимость от пары синхронизированных объектов. Предположим, что один поток входит в монитор объекта Х, а другой - в монитор объекта Y. Если поток в объекте Х пытается вызвать любой синхронизированный метод объекта Y, а объект Y в свою очередь пытается вызвать любой синхронизированный метод объекта Х, то потоки будут ожидать вечно.

## Лайвлок (Livelock)

"Livelock"- тип взаимной блокировки, при котором несколько потоков продолжают свою работу, но попадают в зацикленность при попытке получения каких-либо ресурсов. Фактической ошибки не возникает, но КПД системы падает до 0. Часто возникает в результате попыток предотвращения deadlock'а.

Пример: Метод пытается выполнить какую-либо работу, используя 2 внешних объекта. Сперва он получает блокировку по одному из объектов, а затем проверяет, свободен ли второй объект. Если объект свободен - получает блокировку по нему и выполняет работу, если занят - освобождает первый объект и ждёт, когда они оба освободятся. 2 потока одновременно вызывают этот метод. Поток 1 блокирует первый объект. Поток 2 блокирует второй объект. Оба проверяют, свободен ли второй ресурс - обнаруживают, что он занят и освобождают занятый ресурс. Оба потока обнаруживают, что оба ресурса свободны и начинают процесс блокировки сначала. Livelock.

Способы борьбы:

- Так же, как и в случае с deadlock'ом - блокировать объекты всегда в одинаковом порядке
- Метод может производить блокировку по своему внутреннему объекту и уже после этого пытаться получить внешние ресурсы.

## Volatile

`volatile` - (изменчивый, не постоянный). Его необходимо использовать для переменных, которые используются разными потоками. Это связано с тем, что значение переменной, объявленной без volatile, может кэшироваться отдельно для каждого потока, и значение из этого кэша может различаться для каждого из них. Объявление переменной с ключевым словом volatile отключает для неё такое кэширование и все запросы к переменной будут направляться непосредственно в память.

## Исполнители

Concurrency API вводит понятие сервиса-исполнителя (ExecutorService) — высокоуровневую замену работе с потоками напрямую. Исполнители выполняют задачи асинхронно и обычно используют пул потоков, так что нам не надо создавать их вручную. Все потоки из пула будут использованы повторно после выполнения задачи, а значит, мы можем создать в приложении столько задач, сколько хотим, используя один исполнитель.

Вот как будет выглядеть наш первый пример с использованием исполнителя:

```java
ExecutorService executor = Executors.newSingleThreadExecutor();
executor.submit(() -> {
    String threadName = Thread.currentThread().getName();
    System.out.println("Hello " + threadName);
});

// => Hello pool-1-thread-1
```

Класс Executors предоставляет удобные методы-фабрики для создания различных сервисов исполнителей. В данном случае мы использовали исполнитель с одним потоком.

Результат выглядит так же, как в прошлый раз. Но у этого кода есть важное отличие — он никогда не остановится. Работу исполнителей надо завершать явно. Для этого в интерфейсе ExecutorService есть два метода: shutdown(), который ждет завершения запущенных задач, и shutdownNow(), который останавливает исполнитель немедленно.

Вот как я предпочитаю останавливать исполнителей:

```java
try {
    System.out.println("attempt to shutdown executor");
    executor.shutdown();
    executor.awaitTermination(5, TimeUnit.SECONDS);
}
catch (InterruptedException e) {
    System.err.println("tasks interrupted");
}
finally {
    if (!executor.isTerminated()) {
        System.err.println("cancel non-finished tasks");
    }
    executor.shutdownNow();
    System.out.println("shutdown finished");
}
```

Исполнитель пытается завершить работу, ожидая завершения запущенных задач в течение определенного времени (5 секунд). По истечении этого времени он останавливается, прерывая все незавершенные задачи.

## `Callable` и `Future`

Кроме Runnable, исполнители могут принимать другой вид задач, который называется `Callable`. `Callable` — это также функциональный интерфейс, но, в отличие от Runnable, он может возвращать значение.

Давайте напишем задачу, которая возвращает целое число после секундной паузы:

```java
Callable task = () -> {
    try {
        TimeUnit.SECONDS.sleep(1);
        return 123;
    }
    catch (InterruptedException e) {
        throw new IllegalStateException("task interrupted", e);
    }
};
```

Callable-задачи также могут быть переданы исполнителям. Но как тогда получить результат, который они возвращают? Поскольку метод submit() не ждет завершения задачи, исполнитель не может вернуть результат задачи напрямую. Вместо этого исполнитель возвращает специальный объект Future, у которого мы сможем запросить результат задачи.

```java
ExecutorService executor = Executors.newFixedThreadPool(1);
Future<Integer> future = executor.submit(task);

System.out.println("future done? " + future.isDone());

Integer result = future.get();

System.out.println("future done? " + future.isDone());
System.out.print("result: " + result);
```

После отправки задачи исполнителю мы сначала проверяем, завершено ли ее выполнение, с помощью метода isDone(). Поскольку задача имеет задержку в одну секунду, прежде чем вернуть число, я более чем уверен, что она еще не завершена.

Вызов метода get() блокирует поток и ждет завершения задачи, а затем возвращает результат ее выполнения. Теперь future.isDone() вернет true, и мы увидим на консоли следующее:

```java
future done? false
future done? true
result: 123
```

Задачи жестко связаны с сервисом исполнителей, и, если вы его остановите, попытка получить результат задачи выбросит исключение:

```java
executor.shutdownNow();
future.get();
```

Вы, возможно, заметили, что на этот раз мы создаем сервис немного по-другому: с помощью метода newFixedThreadPool(1), который вернет исполнителя с пулом в один поток. Это эквивалентно вызову метода newSingleThreadExecutor(), однако мы можем изменить количество потоков в пуле.

## Что содержится в java.util.concurrent

![java.util.concurrent](/content/assets/JavaCore/java.util.concurrent.png)

**Concurrent Collections** — набор коллекций, более эффективно работающие в многопоточной среде нежели стандартные универсальные коллекции из java.util пакета. Вместо базового враппера Collections.synchronizedList с блокированием доступа ко всей коллекции используются блокировки по сегментам данных или же оптимизируется работа для параллельного чтения данных по wait-free алгоритмам.

**Queues** — неблокирующие и блокирующие очереди с поддержкой многопоточности. Неблокирующие очереди заточены на скорость и работу без блокирования потоков. Блокирующие очереди используются, когда нужно «притормозить» потоки «Producer» или «Consumer», если не выполнены какие-либо условия, например, очередь пуста или перепонена, или же нет свободного «Consumer»'a.

**Synchronizers** — вспомогательные утилиты для синхронизации потоков. Представляют собой мощное оружие в «параллельных» вычислениях.

**Executors** — содержит в себе отличные фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов. 

**Locks** — представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized, wait, notify, notifyAll.

**Atomics** — классы с поддержкой атомарных операций над примитивами и ссылками.
