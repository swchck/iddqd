# JDBC

## Что такое JDBC

API JDBC (Java DataBase Connectivity) - стандартный прикладной интерфейс языка Java для организации взаимодействия между приложением и СУБД. Взаимодействие осуществляется с помощью драйверов JDBC, обеспечиваю щих реализацию общих интерфейсов для конкретных СУБД и конкретних протоколов. В JDBC определяются четыре типа драйверов.

## Этапы работы с базой данных с использованием JDBC

Этапы работы с базой данных с использованием JDBC:

- Подключение библиотеки с классом-драйвером базы данных
- Установка соединения с БД
- Создание объекта для передачи запросов
- Выполнение запроса
- Обработка результатов выполнения запроса
- Закрытие соединения

## Как создать Connection

Для установки соединения с БД вызывается статический метод `getConnection()` класса `java.sql.DriverManager`. В качестве параметров методу передаються URL базы данных, логин пользователя БД и пароль доступа. Загрузка класса драйвера базы данных при отсутствии ссылки на экземпляр этого класса в JDBC происходит автоматически при установке соединения екземпляром `DriverManager`. Метод возвращает объект `Connection`. URL базы данных, состоящий из типа и адреса физического расположения БД, может создаваться в виде отдельной строки или извлекаться из файла ресурсов. Соответственно:

```Java
Connection cn = DriverManager.getConnection("jdbc:sql://localhost:port/dbName", "user", "pass")
```

В результате будет возвращен объект `Connection` и будет одно установленное соединение с БД с именем testphones. Класс `DriverManager` предоставляет средства для управления набором драйверов баз данных.

## Чем отличается `Statement` от `PreparedStatement`

Объект `Statement` используется для выполнения SQL-запросов к БД. Существует три типа объектов `Statement`. Все три служат как бы контейнерами для выполнения SQL-выражений через данное соединение: `Statement`, `PreparedStatement`, наследующий от `Statement`, и `CallableStatement`, наследующий от `PreparedStatement`.

Они специализируются на различных типах запросов: 

- `Statement` используется для выполнения простых SQL-запросов без параметров
- `PreparedStatement` используется для выполнения прекомпилированных SQL-запросов с или без входных (IN) параметров
- `CallableStatement` используется для вызовов хранимых процедур

Интерфейс `Statement` предоставляет базовые методы для выполнения запросов и извлечения результатов. Интерфейс `PreparedStatement` добавляет методы управления входными (IN) параметрами; `CallableStatement` добавляет методы для манипуляции выходними (OUT) параметрами.

Интерфейс `PreparedStatement` наследует от `Statement` и отличается от последнего следующим:

- Экземпляры `PreparedStatement` "помнят" скомпилированные SQL-выражения, именно поэтому они называются "prepared" ("подготовленные")
- SQL-выражения в `PreparedStatement` могут иметь один или более входной (IN)параметр. **Входной параметр** - это параметр, чье значение не указывается при создании SQL-выражения. Вместо него в выражении на месте каждого входного параметра ставится знак ("?"). Значение каждого вопросительного знака устанавливается методами setXXX перед выполнением запроса.

## Как вызвать хранимую процедуру

Хранимые процедуры – это именованный набор операторов Transact-SQL хранящийся на сервере. Такую процедуру можно легко вызвать из Java-класса с помощью специального синтаксиса. 

При вызове такой процедуры необходимо указать ее имя и определить список параметров. Имя и список параметров посылаются по JDBC-соединению в СУБД, которая выполняет вызываемую процедуру и возвращает результат (если таковой имеется) обратно, используя это же соединение.

JDBC Java-код для выполнения хранимой процедуры, использующий объект `Statement` без параметров:

```Java
public static void executeStoredProcedureNoParams(Connection c) {
    try {
        Statement stmt = c.createStatement();
        ResultSet rs = stmt.executrQuery("{CALL STPROCNAME}");
        while (rs.next()) {
            SystemOutPrintln(rs.getString(name));
        }
        rs.close();
        stmt.close();
    }
    catch (Exception e) {
        e.printStackTrace()
    }
}
```

## Как правильно закрыть `Connection`

После того, как база больше не нужна, соединение закрывается. Для того, чтобы правильно пользоваться приведенными методами, программисту требуется знать типы полей БД. В распределенных системах это знание предполагается изначально. В Java 7 для объектов-ресурсов, требующих закрытия, реализована технология try with resources.

## Какие есть уровни изоляции транзакций

Уровни изоляции транзакций определены в виде констант интерфейса `Connection` (по возрастанию уровня ограничения):

- **TRANSACTION_NONE** - информирует о том, что драйвер не поддерживает транзакции
- **TRANSACTION_READ_UNCOMMITTED** - позволяет транзакциям видеть несохраненные изменения данных, что разрешает грязное, неповторяющееся и фантомное чтения
- **TRANSACTION_READ_COMMITTED** - означает, что любое изменение,сделанное в транзакции, не видно вне ее, пока она не сохранена. Это предотвращает грязное чтение, но разрешает неповторяющееся и фантомное
- **TRANSACTION_REPEATABLE_READ** - запрещает грязное и неповторяющееся чтение, но фантомное разрешено
- **TRANSACTION_SERIALIZABLE** - определяет, что грязное, неповторяющееся и фантомное чтения запрещены

## Какие есть типов чтения транзакций

Для транзакций существует несколько типов чтения:

- Грязное чтение (dirty reads) происходит, когда транзакциям разрешено видеть несохраненные изменения данных. Иными словами, изменения, сделанные в одной транзакции, видны вне ее до того, как она была сохранена. Если изменения не будут сохранены, то, вероятно, другие транзакции выполняли работу на основе некорректных данных;
- Неповторяющееся чтение (nonrepeatable reads) происходит, когда транзакция А читает строку, транзакция Б изменяет эту строку, транзакция А читает ту же строку и получает обновленные данные;
- Фантомное чтение (phantom reads) происходит, когда транзакция А считывает все строки, удовлетворяющие WHERE-условию, транзакция Б вставляет новую или удаляет одну из строк, которая удовлетворяет этому условию, транзакция А еще раз считывает все строки, удовлетворяющие WHERE-условию, уже вместе с новой строкой или недосчитавшись старой.
